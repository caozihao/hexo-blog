{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/one/source/012cf6a10129e2275d79d6adac7f3b02.woff","path":"012cf6a10129e2275d79d6adac7f3b02.woff","modified":0,"renderable":1},{"_id":"themes/one/source/570eb83859dc23dd0eec423a49e147fe.woff2","path":"570eb83859dc23dd0eec423a49e147fe.woff2","modified":0,"renderable":1},{"_id":"themes/one/source/index.html","path":"index.html","modified":0,"renderable":1},{"_id":"themes/one/source/a37b0c01c0baf1888ca812cc0508f6e2.ttf","path":"a37b0c01c0baf1888ca812cc0508f6e2.ttf","modified":0,"renderable":1},{"_id":"source/images/HelloHexo/index_right2.jpg","path":"images/HelloHexo/index_right2.jpg","modified":0,"renderable":0},{"_id":"themes/one/source/52342c4f7685bd4be2f462665845d4e9.js","path":"52342c4f7685bd4be2f462665845d4e9.js","modified":0,"renderable":1},{"_id":"themes/one/source/e79bfd88537def476913f3ed52f4f4b3.eot","path":"e79bfd88537def476913f3ed52f4f4b3.eot","modified":0,"renderable":1},{"_id":"themes/one/source/embed.js","path":"embed.js","modified":0,"renderable":1},{"_id":"source/images/head/avatar.jpg","path":"images/head/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/head/myself.jpg","path":"images/head/myself.jpg","modified":0,"renderable":0},{"_id":"source/images/算法/bg.jpg","path":"images/算法/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/HelloHexo/index_bg.jpg","path":"images/HelloHexo/index_bg.jpg","modified":0,"renderable":0},{"_id":"source/images/HelloHexo/index_right.jpg","path":"images/HelloHexo/index_right.jpg","modified":0,"renderable":0},{"_id":"source/images/将hexo配置到github上/bg.png","path":"images/将hexo配置到github上/bg.png","modified":0,"renderable":0},{"_id":"source/images/HelloHexo/head_right.png","path":"images/HelloHexo/head_right.png","modified":0,"renderable":0},{"_id":"source/images/HelloHexo/index_bottom.jpg","path":"images/HelloHexo/index_bottom.jpg","modified":0,"renderable":0},{"_id":"themes/one/source/bundle.js","path":"bundle.js","modified":0,"renderable":1},{"_id":"themes/one/source/vendor.js","path":"vendor.js","modified":0,"renderable":1},{"_id":"source/images/head/bg.png","path":"images/head/bg.png","modified":0,"renderable":0},{"_id":"source/images/关于本站/bg.jpg","path":"images/关于本站/bg.jpg","modified":0,"renderable":0},{"_id":"themes/one/source/bundle.js.map","path":"bundle.js.map","modified":0,"renderable":1},{"_id":"themes/one/source/vendor.js.map","path":"vendor.js.map","modified":0,"renderable":1},{"_id":"source/images/HelloHexo/index_bottom2.jpg","path":"images/HelloHexo/index_bottom2.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/关于我.md","hash":"c102c9b6d3a6cefe3c1c6c3c26615684041cd01a","modified":1545790096841},{"_id":"source/关于本站.md","hash":"b2d7b8324e22e04721144efca186d7f7eecf1c5f","modified":1545790096841},{"_id":"themes/one/_config.yml","hash":"90e8000996df774a439501a49b310b4e5d034371","modified":1545794588611},{"_id":"themes/one/_config.yml.example","hash":"c9b1764a081b30f96f7b90dba6813628afb03e3e","modified":1545790096884},{"_id":"source/_data/menu.yml","hash":"e71010c594dc9a54320658da421f581dfefae46d","modified":1545790096779},{"_id":"source/_posts/Hello-Hexo.md","hash":"48560330675fad2fbe86b8b6f10547b1a44999fd","modified":1545794081766},{"_id":"source/_posts/K最近邻算法.md","hash":"0b7780eb79b21008306855fde874a169a3026445","modified":1545794069602},{"_id":"source/_posts/动态规划，最长公共子串，最长公共子序列.md","hash":"7e0d91856c271a2a2643d13c06273021bde09a42","modified":1545794078726},{"_id":"source/_posts/几种常用算法.md","hash":"b83b65dc8ef53f75eb08d98060aa65f23de915d5","modified":1545794074853},{"_id":"source/_posts/将hexo配置到github上.md","hash":"7cdd431b44b62f546a7f3f26386b02b62ef2adee","modified":1545792966400},{"_id":"source/_posts/贪婪算法之近似算法（广播集合覆盖问题）.md","hash":"578639cd35b9fc6f3814493fd16dd2f88123ad30","modified":1545794064554},{"_id":"themes/one/layout/index.ejs","hash":"c5b59cfefd44b8190a99cf640ec2cee204285510","modified":1545790096884},{"_id":"themes/one/layout/layout.ejs","hash":"bdd9bfd33122ace81b2f9ba72de59bdfd64645c8","modified":1545790096885},{"_id":"themes/one/scripts/helper.js","hash":"3c2df00f94625e8061b71fff33fdd33aad58b48f","modified":1545790096885},{"_id":"themes/one/scripts/index.js","hash":"3cf06b21ec1c8af043ea23cace3d779a0d65705f","modified":1545790096886},{"_id":"themes/one/source/012cf6a10129e2275d79d6adac7f3b02.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1545790096890},{"_id":"themes/one/source/570eb83859dc23dd0eec423a49e147fe.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1545790096892},{"_id":"themes/one/source/index.html","hash":"add1acb9ba3df604955502ed6ff844356d94f54e","modified":1545790096925},{"_id":"themes/one/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545790096887},{"_id":"themes/one/source/a37b0c01c0baf1888ca812cc0508f6e2.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1545790096894},{"_id":"source/images/HelloHexo/hello.js","hash":"2978e693731b7890655b0592dfefd724b03d0eae","modified":1545790096783},{"_id":"source/images/HelloHexo/index_right2.jpg","hash":"80fc3a9014547b12fd8338a8f7e4df8ff8b15165","modified":1545790096818},{"_id":"source/live2d_models/shizuku/shizuku.model.json","hash":"fd171a52336ab38781c51fadcaaa1336504aa25b","modified":1545790096840},{"_id":"themes/one/scripts/lib/css_lsload.js","hash":"9c5db6a44132f76573b3583cd965b30844b61a51","modified":1545790096887},{"_id":"themes/one/scripts/lib/get_file_hex.js","hash":"079a20b2919d5aa77169e1fb243ef3d26a46401c","modified":1545790096888},{"_id":"themes/one/scripts/lib/js_hex.js","hash":"c6d6b268553574f5ea07559ffba9579b47a7c3d6","modified":1545790096888},{"_id":"themes/one/scripts/lib/js_lsload.js","hash":"df3715e4378791f9480276695abffe4c7295cda0","modified":1545790096888},{"_id":"themes/one/scripts/lib/path_for.js","hash":"490d6ef68a7dc2d7b6f863e22741ecd718ff4271","modified":1545790096889},{"_id":"themes/one/scripts/lib/restful.js","hash":"2b576fadcc5cd6d166ac3bb8c1e950655f4efb1a","modified":1545790096889},{"_id":"themes/one/scripts/lib/router-add-one.js","hash":"0218823bcb61628e010e87206169b0a84e5f92c7","modified":1545790096890},{"_id":"themes/one/source/52342c4f7685bd4be2f462665845d4e9.js","hash":"c77d096637e0b7c8d03d24000a633d438d080956","modified":1545790096892},{"_id":"themes/one/source/e79bfd88537def476913f3ed52f4f4b3.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1545790096924},{"_id":"themes/one/source/embed.js","hash":"31ef69574e8863f7a928add9bb53ad35683732fc","modified":1545790096924},{"_id":"source/images/head/avatar.jpg","hash":"0852c327fb309c51081b8f47fa7e9282c6ba22fb","modified":1545790096819},{"_id":"source/images/head/myself.jpg","hash":"77752a89c14247acb2ed06424cbb0dbea81336c9","modified":1545790096824},{"_id":"source/images/算法/bg.jpg","hash":"7afc9af23fcbf6c1071fc67f1f124110cc0e514d","modified":1545791812278},{"_id":"source/images/HelloHexo/index_bg.jpg","hash":"64620c354a784b7cccc58b011276408ae569b76b","modified":1545790096785},{"_id":"source/images/HelloHexo/index_right.jpg","hash":"2b78e2b48e7c3ce937dc0703f19f535b8126d659","modified":1545790096817},{"_id":"source/images/将hexo配置到github上/bg.png","hash":"62ef6866d9d3b2027eed340b86356474d822e33b","modified":1545792263470},{"_id":"source/images/HelloHexo/head_right.png","hash":"328f3b66d760a5d72e2c52313c90dacb3baf7a7b","modified":1545790096783},{"_id":"source/images/HelloHexo/index_bottom.jpg","hash":"a5f2bdfacef363933a0893a06bc8c923ea5b6338","modified":1545790096788},{"_id":"themes/one/source/bundle.js","hash":"4c519346b77a7fa521e02d20c533b7fa6b8cec15","modified":1545790096898},{"_id":"themes/one/source/vendor.js","hash":"5a09acf1f197788c3f7a2263646a64684ac40826","modified":1545790096929},{"_id":"source/images/head/bg.png","hash":"572226e2f72459f8b034fbf5e64973c36cfdd422","modified":1545790096823},{"_id":"source/images/关于本站/bg.jpg","hash":"bf8ab492cccf7bb7f2cc7da952a8c1a4f3cde4af","modified":1545790096837},{"_id":"themes/one/source/bundle.js.map","hash":"433753b9b460ea8422b7f97eefc03d29fd0eb944","modified":1545790096921},{"_id":"themes/one/source/vendor.js.map","hash":"47795ec038673ca72dbd3dd312eefef68677807d","modified":1545790096956},{"_id":"source/images/HelloHexo/index_bottom2.jpg","hash":"1791fc594742bf0e4c7f8f540dfb73e0a8106cca","modified":1545790096814},{"_id":"public/images/HelloHexo/hello.js","hash":"2978e693731b7890655b0592dfefd724b03d0eae","modified":1545811841590},{"_id":"public/live2d_models/shizuku/shizuku.model.json","hash":"19a05bd41b806a935cea42c2000626fc82da2536","modified":1545811841589},{"_id":"public/api/site.json","hash":"f15f0bc30d4cf05647b6662c018909ee9c7113f4","modified":1545811903181},{"_id":"public/api/theme.json","hash":"51d5fa0afeecf1d34edb6698c87ac51c09f7cb3c","modified":1545811841753},{"_id":"public/api/categories/项目.json","hash":"912af85298c4d176f1ba86d2fe2a11ec02140059","modified":1545811841774},{"_id":"public/api/categories.json","hash":"ab4ba65d2b6635136ef68d0202745a0a79237537","modified":1545811841773},{"_id":"public/api/tags.json","hash":"5ebf1366bfa316264fb7545bf2bcac49aaca2c1a","modified":1545811841773},{"_id":"public/api/tags/算法.json","hash":"6eb6e43b82e7844030708a41801007caa2bef464","modified":1545811841774},{"_id":"public/api/tags/介绍.json","hash":"e1e731d713b4bfbe3c4450a8d34ae92e6c75b241","modified":1545811841775},{"_id":"public/api/tags/Hexo.json","hash":"5e74ec4660fcbf21196d81fd1ec8db1b62b498a6","modified":1545811841775},{"_id":"public/api/tags/配置.json","hash":"6c838f99f1081d60f40d08f10ea71669a945899a","modified":1545811841775},{"_id":"public/api/posts.json","hash":"5887dd88d926230989f49c45c1a0f926802f6d02","modified":1545811841777},{"_id":"public/api/posts/1.json","hash":"5887dd88d926230989f49c45c1a0f926802f6d02","modified":1545811841777},{"_id":"public/api/articles/将hexo配置到github上.json","hash":"2400f80b1cd863dd988b2e02b55838f27b1f78f4","modified":1545811841777},{"_id":"public/api/articles/Hello-Hexo.json","hash":"768308f88aa7bf193b2f50bd048919b06ada89ea","modified":1545811841778},{"_id":"public/api/page/关于本站.json","hash":"e4f47eff2086cfd3270b27b8a8b25eb898ca3f71","modified":1545811841778},{"_id":"public/api/page/关于我.json","hash":"d70c79f4f1fde831fffa7d94664501f5637cb912","modified":1545811841778},{"_id":"public/api/page/.json","hash":"14397922a4766cc146a42d5f0e3b54e4a77cc252","modified":1545811841779},{"_id":"public/api/tags/最长公共子序列.json","hash":"cbcadd961f2599482c71d810b73f391c5d39f863","modified":1545811841774},{"_id":"public/api/tags/动态规划.json","hash":"49f7caa544568af273fba7e6e61ab07777a6e01f","modified":1545811841774},{"_id":"public/api/tags/最长公共子串.json","hash":"fef9b19541f09dfc92eb84e63ea323e700c03a7e","modified":1545811841774},{"_id":"public/api/tags/K最近邻算法.json","hash":"bf6971813193a7789743d0d86c170398aa17e086","modified":1545811841775},{"_id":"public/api/tags/贪婪算法.json","hash":"2c70e4c9fe95f6f2ceb58722342bf3ddf07849df","modified":1545811841775},{"_id":"public/api/articles/K最近邻算法.json","hash":"c64c653f99517997349bcc9d2c077718b8eea87e","modified":1545811841777},{"_id":"public/api/articles/动态规划，最长公共子串，最长公共子序列.json","hash":"9f344f92bda190ca2320acc60d52473bb5700f62","modified":1545811841777},{"_id":"public/api/articles/几种常用算法.json","hash":"90b1666d7cad5fa613f1f1620b632050dae1566d","modified":1545811841777},{"_id":"public/api/articles/贪婪算法之近似算法（广播集合覆盖问题）.json","hash":"ef637c2aba72db67b882789f0ade5e9bf576aaaa","modified":1545811841777},{"_id":"public/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903365},{"_id":"public/关于本站.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903365},{"_id":"public/关于我.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903366},{"_id":"public/2017/12/10/将hexo配置到github上/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903367},{"_id":"public/2017/11/26/Hello-Hexo/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903367},{"_id":"public/categories/项目/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903370},{"_id":"public/archives/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903367},{"_id":"public/archives/2017/12/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903369},{"_id":"public/archives/2018/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903370},{"_id":"public/archives/2017/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903369},{"_id":"public/archives/2017/11/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903369},{"_id":"public/archives/2018/12/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903370},{"_id":"public/tags/算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903371},{"_id":"public/tags/Hexo/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903371},{"_id":"public/tags/介绍/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/tags/配置/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/post/将hexo配置到github上/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903373},{"_id":"public/post/Hello-Hexo/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903373},{"_id":"public/page/关于本站/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903373},{"_id":"public/page//index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903374},{"_id":"public/page/关于我/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903373},{"_id":"public/search/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903374},{"_id":"public/2018/12/26/动态规划，最长公共子串，最长公共子序列/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903366},{"_id":"public/2018/12/25/几种常用算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903367},{"_id":"public/2018/12/26/K最近邻算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903366},{"_id":"public/2018/12/26/贪婪算法之近似算法（广播集合覆盖问题）/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903367},{"_id":"public/tags/最长公共子串/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903371},{"_id":"public/tags/动态规划/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903371},{"_id":"public/tags/最长公共子序列/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903371},{"_id":"public/tags/K最近邻算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/tags/贪婪算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/post/动态规划，最长公共子串，最长公共子序列/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/post/贪婪算法之近似算法（广播集合覆盖问题）/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/post/K最近邻算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/post/几种常用算法/index.html","hash":"41650e15e5a440e0104322dff96aac621af9f224","modified":1545811903372},{"_id":"public/012cf6a10129e2275d79d6adac7f3b02.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1545811841997},{"_id":"public/570eb83859dc23dd0eec423a49e147fe.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1545811841997},{"_id":"public/images/HelloHexo/index_right2.jpg","hash":"80fc3a9014547b12fd8338a8f7e4df8ff8b15165","modified":1545811841997},{"_id":"public/live2d/assets/exp/f03.exp.json","hash":"fbf7729e504f14f83f976827fcf62301a6579a34","modified":1545811841998},{"_id":"public/live2d/assets/exp/f02.exp.json","hash":"241b6afafa2e25c6d7a54692a8b5aa060a137ab1","modified":1545811841998},{"_id":"public/live2d/assets/exp/f04.exp.json","hash":"35e746ede62e7090e7dfb08561d77772f58b4153","modified":1545811841998},{"_id":"public/live2d/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1545811841998},{"_id":"public/live2d/assets/mtn/flickHead_01.mtn","hash":"a1011d6bf397bcd3c3c968d9616f88fe1ffbc83c","modified":1545811841999},{"_id":"public/live2d/assets/mtn/flickHead_00.mtn","hash":"f64c79c9171660db5c440bef229ac2e35a1597d5","modified":1545811841998},{"_id":"public/live2d/assets/mtn/flickHead_02.mtn","hash":"d3c9c0acb4dc25a2274f3b9faa71e5ce60ad92e4","modified":1545811841999},{"_id":"public/live2d/assets/mtn/idle_01.mtn","hash":"88c2494655dbb712b842f03232b619f381753d52","modified":1545811841999},{"_id":"public/live2d/assets/mtn/idle_00.mtn","hash":"378b4577217c604c9d28ab4edf8b707c8d8c2fbb","modified":1545811841999},{"_id":"public/live2d/assets/mtn/idle_02.mtn","hash":"7f5d2cf8706007c8659938eba132a68c470a4c26","modified":1545811841999},{"_id":"public/live2d/assets/mtn/pinchIn_00.mtn","hash":"70978b4c983f6a9fd6d3d9c24571586f7d6eac30","modified":1545811841999},{"_id":"public/live2d/assets/mtn/pinchIn_01.mtn","hash":"a5fefb45115695db72b9499e627a51b2b9394f2c","modified":1545811841999},{"_id":"public/live2d/assets/mtn/pinchOut_00.mtn","hash":"e07fe8fd8c2810e3c1d28b730bd49c8c25849bad","modified":1545811842000},{"_id":"public/live2d/assets/mtn/pinchIn_02.mtn","hash":"aa0d66ca9b06c374577fd7e64e89756de1e1f2ae","modified":1545811841999},{"_id":"public/live2d/assets/mtn/pinchOut_01.mtn","hash":"e05df948d08b17f34c993a9c1f901190509d5db0","modified":1545811842000},{"_id":"public/live2d/assets/mtn/pinchOut_02.mtn","hash":"b323fd350d334b33bbdfb31194ae664089986c27","modified":1545811842000},{"_id":"public/live2d/assets/mtn/shake_02.mtn","hash":"2702970805e07777974c383613e631730982bcff","modified":1545811842000},{"_id":"public/live2d/assets/mtn/shake_01.mtn","hash":"e812985a56796e122018f9d57d1606a4866ff7d1","modified":1545811842000},{"_id":"public/live2d/assets/mtn/shake_00.mtn","hash":"5185d02c7ab9f0bec3d4a890b54b2378e553373d","modified":1545811842000},{"_id":"public/live2d/assets/mtn/tapBody_01.mtn","hash":"78fca17436ab5e065e27f419f135aa6c0a0b52ef","modified":1545811842000},{"_id":"public/live2d/assets/mtn/tapBody_02.mtn","hash":"a75acb51c1191ce5050d3ee1af6f2dcc787c7c5e","modified":1545811842000},{"_id":"public/live2d/assets/shizuku.model.json","hash":"fd171a52336ab38781c51fadcaaa1336504aa25b","modified":1545811842000},{"_id":"public/live2d/assets/shizuku.physics.json","hash":"6484d646e79a44c83784c6ae434cf7349746c5c8","modified":1545811842000},{"_id":"public/live2d/assets/mtn/tapBody_00.mtn","hash":"835aa3d4a8fbd26c0bb66b164a19464fa3f17a99","modified":1545811842000},{"_id":"public/live2d/assets/shizuku.pose.json","hash":"ac5505efbf80ba0a2e5783d67fe232bc5c6f1f80","modified":1545811842001},{"_id":"public/live2d/assets/snd/flickHead_00.mp3","hash":"356388d939006b03cf9e6158c603b58d4800bec1","modified":1545811842001},{"_id":"public/live2d/assets/snd/flickHead_01.mp3","hash":"436d0bbccf6e7a2744447554947eee4563608970","modified":1545811842001},{"_id":"public/live2d/assets/snd/flickHead_02.mp3","hash":"5f63477ce63f2073e24d68fea906fe136fe6349e","modified":1545811842001},{"_id":"public/live2d/assets/snd/pinchIn_00.mp3","hash":"f9baa3b7cadec20b714135fc49cfab3ff6adeeb4","modified":1545811842001},{"_id":"public/live2d/assets/snd/pinchIn_01.mp3","hash":"d5c8cc6f61b56222a83a5174f75006f83c3b88da","modified":1545811842001},{"_id":"public/live2d/assets/snd/shake_00.mp3","hash":"f65dd58e7b44ec5c865d13c190316070b625b5fe","modified":1545811842001},{"_id":"public/live2d/assets/snd/shake_01.mp3","hash":"c1e0e8a07ff268ee06c2b7825d1b645e193f21b9","modified":1545811842001},{"_id":"public/live2d/device.min.js","hash":"ad8ffa5cc29d478f718c73eef31052dd4cdae7b6","modified":1545811842002},{"_id":"public/live2d/assets/snd/shake_02.mp3","hash":"8882b94bce00f09232588b7301badb105fa8acab","modified":1545811842001},{"_id":"public/live2d/assets/snd/tapBody_02.mp3","hash":"15e7815ed0a0e5164e18e0c53b97aedc742a134d","modified":1545811842002},{"_id":"public/live2d/assets/snd/tapBody_00.mp3","hash":"003e68a59a9c8392e230f34c91860efbd946277a","modified":1545811842002},{"_id":"public/live2d/assets/snd/tapBody_01.mp3","hash":"5314b50f153df71559e51e2586581c006df00722","modified":1545811842002},{"_id":"public/a37b0c01c0baf1888ca812cc0508f6e2.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1545811842034},{"_id":"public/images/head/avatar.jpg","hash":"0852c327fb309c51081b8f47fa7e9282c6ba22fb","modified":1545811842034},{"_id":"public/images/head/myself.jpg","hash":"77752a89c14247acb2ed06424cbb0dbea81336c9","modified":1545811842067},{"_id":"public/live2d/assets/moc/shizuku.1024/texture_00.png","hash":"21bdb28b31783e23b26b3aa061e90be4088665aa","modified":1545811842067},{"_id":"public/live2d/assets/moc/shizuku.1024/texture_05.png","hash":"0cd00007fb8bff62a2eb08e1d7c43abab8722224","modified":1545811842067},{"_id":"public/live2d/assets/moc/shizuku.1024/texture_03.png","hash":"07f568a2bb8045b6bdff7783fb4daf62c821f9ab","modified":1545811842067},{"_id":"public/live2d/assets/snd/pinchIn_02.mp3","hash":"5b63e02607571ac601c500995e836e6c861b1c62","modified":1545811842068},{"_id":"public/live2d/assets/snd/pinchOut_00.mp3","hash":"0654f38f6e9fd623eaf8be11b5d58c9d12991949","modified":1545811842068},{"_id":"public/live2d/assets/snd/pinchOut_01.mp3","hash":"8a081030fd53c07bffe3edd48f87a371ca77296b","modified":1545811842068},{"_id":"public/live2d/assets/snd/pinchOut_02.mp3","hash":"554edb2f3838cbdc27d1a9c6b8a9cb6eb465cbdd","modified":1545811842068},{"_id":"public/images/算法/bg.jpg","hash":"7afc9af23fcbf6c1071fc67f1f124110cc0e514d","modified":1545811842067},{"_id":"public/embed.js","hash":"3ac650967aa0f74ec4d7ef5d8d168f7f199e31af","modified":1545811842115},{"_id":"public/52342c4f7685bd4be2f462665845d4e9.js","hash":"ceac2f8363baa1ddb8853d3bcd3c3f3c6d12326a","modified":1545811842115},{"_id":"public/vendor.js","hash":"e0b464cc7951b731a635e80553b0e1829d305c2e","modified":1545811842115},{"_id":"public/bundle.js","hash":"6aa0aa2a54c3ad025ee8a0dbbfd0528358537bdb","modified":1545811842115},{"_id":"public/e79bfd88537def476913f3ed52f4f4b3.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1545811842116},{"_id":"public/images/HelloHexo/index_bg.jpg","hash":"64620c354a784b7cccc58b011276408ae569b76b","modified":1545811842117},{"_id":"public/live2d/script.js","hash":"6b85d115e5785ab244c8ffa8073be3930868589a","modified":1545811842117},{"_id":"public/live2d/assets/moc/shizuku.1024/texture_01.png","hash":"3d0e745f3e560071ee08beeecde186e5ea35d99e","modified":1545811842117},{"_id":"public/live2d/assets/moc/shizuku.1024/texture_04.png","hash":"f764d594841905db8b2998dd61c329866125ad97","modified":1545811842118},{"_id":"public/live2d/assets/moc/shizuku.1024/texture_02.png","hash":"055eb2da9c13e9116be93a1e60c0ea2b660af864","modified":1545811842334},{"_id":"public/images/HelloHexo/index_right.jpg","hash":"2b78e2b48e7c3ce937dc0703f19f535b8126d659","modified":1545811842444},{"_id":"public/images/将hexo配置到github上/bg.png","hash":"62ef6866d9d3b2027eed340b86356474d822e33b","modified":1545811842444},{"_id":"public/images/HelloHexo/head_right.png","hash":"328f3b66d760a5d72e2c52313c90dacb3baf7a7b","modified":1545811842589},{"_id":"public/images/HelloHexo/index_bottom.jpg","hash":"a5f2bdfacef363933a0893a06bc8c923ea5b6338","modified":1545811843434},{"_id":"public/live2d/assets/moc/shizuku.moc","hash":"c2670a0f75830edc89d7fe6d074de4ee67e8dc5d","modified":1545811844310},{"_id":"public/images/head/bg.png","hash":"572226e2f72459f8b034fbf5e64973c36cfdd422","modified":1545811844775},{"_id":"public/images/关于本站/bg.jpg","hash":"bf8ab492cccf7bb7f2cc7da952a8c1a4f3cde4af","modified":1545811844901},{"_id":"public/bundle.js.map","hash":"433753b9b460ea8422b7f97eefc03d29fd0eb944","modified":1545811845009},{"_id":"public/vendor.js.map","hash":"47795ec038673ca72dbd3dd312eefef68677807d","modified":1545811845066},{"_id":"public/images/HelloHexo/index_bottom2.jpg","hash":"1791fc594742bf0e4c7f8f540dfb73e0a8106cca","modified":1545811845233},{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1545790096842},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1545790096843},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1545790096843},{"_id":"themes/landscape/README.md","hash":"e7cc82dc79596f36ba05a8139e7d6b2dfc4ae5f9","modified":1545790096843},{"_id":"themes/landscape/_config.yml","hash":"218c5fb76666696c42dc86e2de4711e6b80befbf","modified":1545790096844},{"_id":"themes/landscape/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1545790096859},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1545790096844},{"_id":"themes/landscape/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1545790096845},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1545790096846},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1545790096845},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1545790096846},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1545790096846},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1545790096847},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1545790096857},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1545790096857},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1545790096858},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1545790096858},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1545790096858},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1545790096859},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1545790096859},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1545790096860},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"a7faab4f3601b28107af5b1095b3966c2f88fec8","modified":1545790096848},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1545790096848},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"3beb0d164acacb6f21e1ca2038158a74ab4a73e4","modified":1545790096849},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1545790096849},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1545790096849},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1545790096850},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"89998e6b2929c4ff5093bbf6b86d611d7420be52","modified":1545790096850},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"148bdf714dd1a7bf55e571f13808ceae079200cc","modified":1545790096851},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1545790096851},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1545790096854},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1545790096855},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1545790096856},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1545790096856},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1545790096857},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1545790096857},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1545790096861},{"_id":"themes/landscape/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1545790096866},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1545790096874},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545790096875},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545790096875},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545790096876},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545790096876},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545790096877},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545790096878},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1545790096881},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1545790096881},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1545790096882},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1545790096883},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1545790096852},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1545790096852},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1545790096853},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1545790096853},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1545790096854},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1545790096854},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1545790096862},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1545790096862},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1545790096862},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1545790096863},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1545790096863},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1545790096863},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1545790096864},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1545790096864},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1545790096864},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1545790096865},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1545790096866},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1545790096866},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1545790096868},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1545790096868},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1545790096871},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545790096878},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1545790096879},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1545790096879},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1545790096879},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1545790096880},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1545790096880},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1545790096871},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1545790096870},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1545790096874}],"Category":[{"name":"项目","_id":"cjq4l55ze0007dcha0ed6xlrr"}],"Data":[{"_id":"menu","data":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}],"Page":[{"title":"关于本站","date":"2017-11-30T14:21:14.000Z","thumbnail":"/images/关于本站/bg.jpg","layout":"page","toc":false,"background":true,"primarycolor":"amber","accentcolor":"blue","_content":"\n###   我希望它成为一个以技术帖为主的博客\n####  正在筹备一个大胆的计划？\n<br>\n<span style=\"font-size:12px;color:#888\">封面画师:  佚名</span>","source":"关于本站.md","raw":"---\ntitle: 关于本站\ndate: 2017-11-30 22:21:14\nthumbnail: /images/关于本站/bg.jpg\nlayout: page\ntoc: false\nbackground: true\nprimarycolor: amber\naccentcolor: blue\n---\n\n###   我希望它成为一个以技术帖为主的博客\n####  正在筹备一个大胆的计划？\n<br>\n<span style=\"font-size:12px;color:#888\">封面画师:  佚名</span>","updated":"2018-12-26T02:08:16.841Z","path":"关于本站.html","comments":1,"_id":"cjq4l55yf0000dchawi5kpfpr","content":"<h3 id=\"我希望它成为一个以技术帖为主的博客\"><a href=\"#我希望它成为一个以技术帖为主的博客\" class=\"headerlink\" title=\"我希望它成为一个以技术帖为主的博客\"></a>我希望它成为一个以技术帖为主的博客</h3><h4 id=\"正在筹备一个大胆的计划？\"><a href=\"#正在筹备一个大胆的计划？\" class=\"headerlink\" title=\"正在筹备一个大胆的计划？\"></a>正在筹备一个大胆的计划？</h4><p><br><br><span style=\"font-size:12px;color:#888\">封面画师:  佚名</span></p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h3 id=\"我希望它成为一个以技术帖为主的博客\"><a href=\"#我希望它成为一个以技术帖为主的博客\" class=\"headerlink\" title=\"我希望它成为一个以技术帖为主的博客\"></a>我希望它成为一个以技术帖为主的博客</h3><h4 id=\"正在筹备一个大胆的计划？\"><a href=\"#正在筹备一个大胆的计划？\" class=\"headerlink\" title=\"正在筹备一个大胆的计划？\"></a>正在筹备一个大胆的计划？</h4><p><br><br><span style=\"font-size:12px;color:#888\">封面画师:  佚名</span></p>\n"},{"title":"关于我","date":"2017-11-30T14:21:14.000Z","updated":"2018-12-26T02:08:16.841Z","tags":["作者"],"thumbnail":"/images/head/myself.jpg","primarycolor":"amber","accentcolor":"blue","_content":"\n#  每天进步一点点！\n\n    天才写手遭遇人生低谷  \n    灵魂画师落入世俗套路  \n    误打误撞走上前端之路\n    为美好的世界献上祝福！\n\n前端 程序员 主攻web node全栈\n\n喜欢 **编程**，游戏，绘画，**音乐**，**动漫**\n\nQQ：[1154791107](http://wpa.qq.com/msgrd?v=3&uin=1154791107&site=qq&menu=yes)\ngithub: [caozihao](https://github.com/caozihao)\n \n</br>\n\n<span style=\"font-size:12px;color:#888\">封面画师: caozihao","source":"关于我.md","raw":"---\ntitle: 关于我\ndate: 2017-11-30 22:21:14\nupdated:\ntags:\n- 作者\nthumbnail: /images/head/myself.jpg\nprimarycolor: amber\naccentcolor: blue\n---\n\n#  每天进步一点点！\n\n    天才写手遭遇人生低谷  \n    灵魂画师落入世俗套路  \n    误打误撞走上前端之路\n    为美好的世界献上祝福！\n\n前端 程序员 主攻web node全栈\n\n喜欢 **编程**，游戏，绘画，**音乐**，**动漫**\n\nQQ：[1154791107](http://wpa.qq.com/msgrd?v=3&uin=1154791107&site=qq&menu=yes)\ngithub: [caozihao](https://github.com/caozihao)\n \n</br>\n\n<span style=\"font-size:12px;color:#888\">封面画师: caozihao","path":"关于我.html","comments":1,"layout":"page","_id":"cjq4l55yh0001dchai3zihhl2","content":"<h1 id=\"每天进步一点点！\"><a href=\"#每天进步一点点！\" class=\"headerlink\" title=\"每天进步一点点！\"></a>每天进步一点点！</h1><pre><code>天才写手遭遇人生低谷  \n灵魂画师落入世俗套路  \n误打误撞走上前端之路\n为美好的世界献上祝福！\n</code></pre><p>前端 程序员 主攻web node全栈</p>\n<p>喜欢 <strong>编程</strong>，游戏，绘画，<strong>音乐</strong>，<strong>动漫</strong></p>\n<p>QQ：<a href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=1154791107&amp;site=qq&amp;menu=yes\" target=\"_blank\" rel=\"noopener\">1154791107</a><br>github: <a href=\"https://github.com/caozihao\" target=\"_blank\" rel=\"noopener\">caozihao</a></p>\n<p><br></p>\n<p><span style=\"font-size:12px;color:#888\">封面画师: caozihao</span></p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h1 id=\"每天进步一点点！\"><a href=\"#每天进步一点点！\" class=\"headerlink\" title=\"每天进步一点点！\"></a>每天进步一点点！</h1><pre><code>天才写手遭遇人生低谷  \n灵魂画师落入世俗套路  \n误打误撞走上前端之路\n为美好的世界献上祝福！\n</code></pre><p>前端 程序员 主攻web node全栈</p>\n<p>喜欢 <strong>编程</strong>，游戏，绘画，<strong>音乐</strong>，<strong>动漫</strong></p>\n<p>QQ：<a href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=1154791107&amp;site=qq&amp;menu=yes\" target=\"_blank\" rel=\"noopener\">1154791107</a><br>github: <a href=\"https://github.com/caozihao\" target=\"_blank\" rel=\"noopener\">caozihao</a></p>\n<p><br></p>\n<p><span style=\"font-size:12px;color:#888\">封面画师: caozihao</span></p>\n"},{"_content":"{\n  \"type\": \"Live2D Model Setting\",\n  \"name\": \"shizuku\",\n  \"model\": \"moc/shizuku.moc\",\n  \"textures\": [\"moc/shizuku.1024/texture_00.png\", \"moc/shizuku.1024/texture_01.png\", \"moc/shizuku.1024/texture_02.png\", \"moc/shizuku.1024/texture_03.png\", \"moc/shizuku.1024/texture_04.png\", \"moc/shizuku.1024/texture_05.png\"],\n  \"physics\": \"shizuku.physics.json\",\n  \"pose\": \"shizuku.pose.json\",\n  \"expressions\": [{\n    \"name\": \"f01\",\n    \"file\": \"exp/f01.exp.json\"\n  }, {\n    \"name\": \"f02\",\n    \"file\": \"exp/f02.exp.json\"\n  }, {\n    \"name\": \"f03\",\n    \"file\": \"exp/f03.exp.json\"\n  }, {\n    \"name\": \"f04\",\n    \"file\": \"exp/f04.exp.json\"\n  }],\n  \"layout\": {\n    \"center_x\": 0,\n    \"y\": 1.2,\n    \"width\": 2.4\n  },\n  \"hit_areas\": [{\n    \"name\": \"head\",\n    \"id\": \"D_REF.HEAD\"\n  }, {\n    \"name\": \"body\",\n    \"id\": \"D_REF.BODY\"\n  }],\n  \"motions\": {\n    \"idle\": [{\n      \"file\": \"mtn/idle_00.mtn\",\n      \"fade_in\": 2000,\n      \"fade_out\": 2000\n    }, {\n      \"file\": \"mtn/idle_01.mtn\",\n      \"fade_in\": 2000,\n      \"fade_out\": 2000\n    }, {\n      \"file\": \"mtn/idle_02.mtn\",\n      \"fade_in\": 2000,\n      \"fade_out\": 2000\n    }],\n    \"tap_body\": [{\n      \"file\": \"mtn/tapBody_00.mtn\",\n      \"sound\": \"snd/tapBody_00.mp3\"\n    }, {\n      \"file\": \"mtn/tapBody_01.mtn\",\n      \"sound\": \"snd/tapBody_01.mp3\"\n    }, {\n      \"file\": \"mtn/tapBody_02.mtn\",\n      \"sound\": \"snd/tapBody_02.mp3\"\n    }],\n    \"pinch_in\": [{\n      \"file\": \"mtn/pinchIn_00.mtn\",\n      \"sound\": \"snd/pinchIn_00.mp3\"\n    }, {\n      \"file\": \"mtn/pinchIn_01.mtn\",\n      \"sound\": \"snd/pinchIn_01.mp3\"\n    }, {\n      \"file\": \"mtn/pinchIn_02.mtn\",\n      \"sound\": \"snd/pinchIn_02.mp3\"\n    }],\n    \"pinch_out\": [{\n      \"file\": \"mtn/pinchOut_00.mtn\",\n      \"sound\": \"snd/pinchOut_00.mp3\"\n    }, {\n      \"file\": \"mtn/pinchOut_01.mtn\",\n      \"sound\": \"snd/pinchOut_01.mp3\"\n    }, {\n      \"file\": \"mtn/pinchOut_02.mtn\",\n      \"sound\": \"snd/pinchOut_02.mp3\"\n    }],\n    \"shake\": [{\n      \"file\": \"mtn/shake_00.mtn\",\n      \"sound\": \"snd/shake_00.mp3\",\n      \"fade_in\": 500\n    }, {\n      \"file\": \"mtn/shake_01.mtn\",\n      \"sound\": \"snd/shake_01.mp3\",\n      \"fade_in\": 500\n    }, {\n      \"file\": \"mtn/shake_02.mtn\",\n      \"sound\": \"snd/shake_02.mp3\",\n      \"fade_in\": 500\n    }],\n    \"flick_head\": [{\n      \"file\": \"mtn/flickHead_00.mtn\",\n      \"sound\": \"snd/flickHead_00.mp3\"\n    }, {\n      \"file\": \"mtn/flickHead_01.mtn\",\n      \"sound\": \"snd/flickHead_01.mp3\"\n    }, {\n      \"file\": \"mtn/flickHead_02.mtn\",\n      \"sound\": \"snd/flickHead_02.mp3\"\n    }]\n  }\n}","source":"live2d_models/shizuku/shizuku.model.json","raw":"{\n  \"type\": \"Live2D Model Setting\",\n  \"name\": \"shizuku\",\n  \"model\": \"moc/shizuku.moc\",\n  \"textures\": [\"moc/shizuku.1024/texture_00.png\", \"moc/shizuku.1024/texture_01.png\", \"moc/shizuku.1024/texture_02.png\", \"moc/shizuku.1024/texture_03.png\", \"moc/shizuku.1024/texture_04.png\", \"moc/shizuku.1024/texture_05.png\"],\n  \"physics\": \"shizuku.physics.json\",\n  \"pose\": \"shizuku.pose.json\",\n  \"expressions\": [{\n    \"name\": \"f01\",\n    \"file\": \"exp/f01.exp.json\"\n  }, {\n    \"name\": \"f02\",\n    \"file\": \"exp/f02.exp.json\"\n  }, {\n    \"name\": \"f03\",\n    \"file\": \"exp/f03.exp.json\"\n  }, {\n    \"name\": \"f04\",\n    \"file\": \"exp/f04.exp.json\"\n  }],\n  \"layout\": {\n    \"center_x\": 0,\n    \"y\": 1.2,\n    \"width\": 2.4\n  },\n  \"hit_areas\": [{\n    \"name\": \"head\",\n    \"id\": \"D_REF.HEAD\"\n  }, {\n    \"name\": \"body\",\n    \"id\": \"D_REF.BODY\"\n  }],\n  \"motions\": {\n    \"idle\": [{\n      \"file\": \"mtn/idle_00.mtn\",\n      \"fade_in\": 2000,\n      \"fade_out\": 2000\n    }, {\n      \"file\": \"mtn/idle_01.mtn\",\n      \"fade_in\": 2000,\n      \"fade_out\": 2000\n    }, {\n      \"file\": \"mtn/idle_02.mtn\",\n      \"fade_in\": 2000,\n      \"fade_out\": 2000\n    }],\n    \"tap_body\": [{\n      \"file\": \"mtn/tapBody_00.mtn\",\n      \"sound\": \"snd/tapBody_00.mp3\"\n    }, {\n      \"file\": \"mtn/tapBody_01.mtn\",\n      \"sound\": \"snd/tapBody_01.mp3\"\n    }, {\n      \"file\": \"mtn/tapBody_02.mtn\",\n      \"sound\": \"snd/tapBody_02.mp3\"\n    }],\n    \"pinch_in\": [{\n      \"file\": \"mtn/pinchIn_00.mtn\",\n      \"sound\": \"snd/pinchIn_00.mp3\"\n    }, {\n      \"file\": \"mtn/pinchIn_01.mtn\",\n      \"sound\": \"snd/pinchIn_01.mp3\"\n    }, {\n      \"file\": \"mtn/pinchIn_02.mtn\",\n      \"sound\": \"snd/pinchIn_02.mp3\"\n    }],\n    \"pinch_out\": [{\n      \"file\": \"mtn/pinchOut_00.mtn\",\n      \"sound\": \"snd/pinchOut_00.mp3\"\n    }, {\n      \"file\": \"mtn/pinchOut_01.mtn\",\n      \"sound\": \"snd/pinchOut_01.mp3\"\n    }, {\n      \"file\": \"mtn/pinchOut_02.mtn\",\n      \"sound\": \"snd/pinchOut_02.mp3\"\n    }],\n    \"shake\": [{\n      \"file\": \"mtn/shake_00.mtn\",\n      \"sound\": \"snd/shake_00.mp3\",\n      \"fade_in\": 500\n    }, {\n      \"file\": \"mtn/shake_01.mtn\",\n      \"sound\": \"snd/shake_01.mp3\",\n      \"fade_in\": 500\n    }, {\n      \"file\": \"mtn/shake_02.mtn\",\n      \"sound\": \"snd/shake_02.mp3\",\n      \"fade_in\": 500\n    }],\n    \"flick_head\": [{\n      \"file\": \"mtn/flickHead_00.mtn\",\n      \"sound\": \"snd/flickHead_00.mp3\"\n    }, {\n      \"file\": \"mtn/flickHead_01.mtn\",\n      \"sound\": \"snd/flickHead_01.mp3\"\n    }, {\n      \"file\": \"mtn/flickHead_02.mtn\",\n      \"sound\": \"snd/flickHead_02.mp3\"\n    }]\n  }\n}","date":"2018-12-26T02:08:16.840Z","updated":"2018-12-26T02:08:16.840Z","path":"live2d_models/shizuku/shizuku.model.json","layout":"false","title":"","comments":1,"_id":"cjq4l5602000vdchauxb9qcir","content":"{\"type\":\"Live2D Model Setting\",\"name\":\"shizuku\",\"model\":\"moc/shizuku.moc\",\"textures\":[\"moc/shizuku.1024/texture_00.png\",\"moc/shizuku.1024/texture_01.png\",\"moc/shizuku.1024/texture_02.png\",\"moc/shizuku.1024/texture_03.png\",\"moc/shizuku.1024/texture_04.png\",\"moc/shizuku.1024/texture_05.png\"],\"physics\":\"shizuku.physics.json\",\"pose\":\"shizuku.pose.json\",\"expressions\":[{\"name\":\"f01\",\"file\":\"exp/f01.exp.json\"},{\"name\":\"f02\",\"file\":\"exp/f02.exp.json\"},{\"name\":\"f03\",\"file\":\"exp/f03.exp.json\"},{\"name\":\"f04\",\"file\":\"exp/f04.exp.json\"}],\"layout\":{\"center_x\":0,\"y\":1.2,\"width\":2.4},\"hit_areas\":[{\"name\":\"head\",\"id\":\"D_REF.HEAD\"},{\"name\":\"body\",\"id\":\"D_REF.BODY\"}],\"motions\":{\"idle\":[{\"file\":\"mtn/idle_00.mtn\",\"fade_in\":2000,\"fade_out\":2000},{\"file\":\"mtn/idle_01.mtn\",\"fade_in\":2000,\"fade_out\":2000},{\"file\":\"mtn/idle_02.mtn\",\"fade_in\":2000,\"fade_out\":2000}],\"tap_body\":[{\"file\":\"mtn/tapBody_00.mtn\",\"sound\":\"snd/tapBody_00.mp3\"},{\"file\":\"mtn/tapBody_01.mtn\",\"sound\":\"snd/tapBody_01.mp3\"},{\"file\":\"mtn/tapBody_02.mtn\",\"sound\":\"snd/tapBody_02.mp3\"}],\"pinch_in\":[{\"file\":\"mtn/pinchIn_00.mtn\",\"sound\":\"snd/pinchIn_00.mp3\"},{\"file\":\"mtn/pinchIn_01.mtn\",\"sound\":\"snd/pinchIn_01.mp3\"},{\"file\":\"mtn/pinchIn_02.mtn\",\"sound\":\"snd/pinchIn_02.mp3\"}],\"pinch_out\":[{\"file\":\"mtn/pinchOut_00.mtn\",\"sound\":\"snd/pinchOut_00.mp3\"},{\"file\":\"mtn/pinchOut_01.mtn\",\"sound\":\"snd/pinchOut_01.mp3\"},{\"file\":\"mtn/pinchOut_02.mtn\",\"sound\":\"snd/pinchOut_02.mp3\"}],\"shake\":[{\"file\":\"mtn/shake_00.mtn\",\"sound\":\"snd/shake_00.mp3\",\"fade_in\":500},{\"file\":\"mtn/shake_01.mtn\",\"sound\":\"snd/shake_01.mp3\",\"fade_in\":500},{\"file\":\"mtn/shake_02.mtn\",\"sound\":\"snd/shake_02.mp3\",\"fade_in\":500}],\"flick_head\":[{\"file\":\"mtn/flickHead_00.mtn\",\"sound\":\"snd/flickHead_00.mp3\"},{\"file\":\"mtn/flickHead_01.mtn\",\"sound\":\"snd/flickHead_01.mp3\"},{\"file\":\"mtn/flickHead_02.mtn\",\"sound\":\"snd/flickHead_02.mp3\"}]}}","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"{\"type\":\"Live2D Model Setting\",\"name\":\"shizuku\",\"model\":\"moc/shizuku.moc\",\"textures\":[\"moc/shizuku.1024/texture_00.png\",\"moc/shizuku.1024/texture_01.png\",\"moc/shizuku.1024/texture_02.png\",\"moc/shizuku.1024/texture_03.png\",\"moc/shizuku.1024/texture_04.png\",\"moc/shizuku.1024/texture_05.png\"],\"physics\":\"shizuku.physics.json\",\"pose\":\"shizuku.pose.json\",\"expressions\":[{\"name\":\"f01\",\"file\":\"exp/f01.exp.json\"},{\"name\":\"f02\",\"file\":\"exp/f02.exp.json\"},{\"name\":\"f03\",\"file\":\"exp/f03.exp.json\"},{\"name\":\"f04\",\"file\":\"exp/f04.exp.json\"}],\"layout\":{\"center_x\":0,\"y\":1.2,\"width\":2.4},\"hit_areas\":[{\"name\":\"head\",\"id\":\"D_REF.HEAD\"},{\"name\":\"body\",\"id\":\"D_REF.BODY\"}],\"motions\":{\"idle\":[{\"file\":\"mtn/idle_00.mtn\",\"fade_in\":2000,\"fade_out\":2000},{\"file\":\"mtn/idle_01.mtn\",\"fade_in\":2000,\"fade_out\":2000},{\"file\":\"mtn/idle_02.mtn\",\"fade_in\":2000,\"fade_out\":2000}],\"tap_body\":[{\"file\":\"mtn/tapBody_00.mtn\",\"sound\":\"snd/tapBody_00.mp3\"},{\"file\":\"mtn/tapBody_01.mtn\",\"sound\":\"snd/tapBody_01.mp3\"},{\"file\":\"mtn/tapBody_02.mtn\",\"sound\":\"snd/tapBody_02.mp3\"}],\"pinch_in\":[{\"file\":\"mtn/pinchIn_00.mtn\",\"sound\":\"snd/pinchIn_00.mp3\"},{\"file\":\"mtn/pinchIn_01.mtn\",\"sound\":\"snd/pinchIn_01.mp3\"},{\"file\":\"mtn/pinchIn_02.mtn\",\"sound\":\"snd/pinchIn_02.mp3\"}],\"pinch_out\":[{\"file\":\"mtn/pinchOut_00.mtn\",\"sound\":\"snd/pinchOut_00.mp3\"},{\"file\":\"mtn/pinchOut_01.mtn\",\"sound\":\"snd/pinchOut_01.mp3\"},{\"file\":\"mtn/pinchOut_02.mtn\",\"sound\":\"snd/pinchOut_02.mp3\"}],\"shake\":[{\"file\":\"mtn/shake_00.mtn\",\"sound\":\"snd/shake_00.mp3\",\"fade_in\":500},{\"file\":\"mtn/shake_01.mtn\",\"sound\":\"snd/shake_01.mp3\",\"fade_in\":500},{\"file\":\"mtn/shake_02.mtn\",\"sound\":\"snd/shake_02.mp3\",\"fade_in\":500}],\"flick_head\":[{\"file\":\"mtn/flickHead_00.mtn\",\"sound\":\"snd/flickHead_00.mp3\"},{\"file\":\"mtn/flickHead_01.mtn\",\"sound\":\"snd/flickHead_01.mp3\"},{\"file\":\"mtn/flickHead_02.mtn\",\"sound\":\"snd/flickHead_02.mp3\"}]}}"},{"_content":"alert('hello world!');","source":"images/HelloHexo/hello.js","raw":"alert('hello world!');","date":"2018-12-26T02:08:16.783Z","updated":"2018-12-26T02:08:16.783Z","path":"images/HelloHexo/hello.js","layout":"false","title":"","comments":1,"_id":"cjq4l5603000wdchaeuw5y54z","content":"alert('hello world!');","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"alert('hello world!');"}],"Post":[{"title":"几种常用算法","date":"2018-12-25T14:06:15.000Z","updated":"2018-12-26T03:14:34.853Z","thumbnail":"/images/算法/bg.jpg","_content":"####  冒泡排序\n\n    for(let i = 0; i < arr.length - 1;i++){\n        for(let j=0;j < arr.length-i-1;j++){\n            if(arr[j] > arr[j+1]){\n                let temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    return arr;\n\n####   选择排序\n\n    const chooseSort = (arr)=>{\n        for(let i =0;i < arr.length-1;i++){\n            let minIndex = i;\n            for(let j = i+1;j<arr.length;j++){\n                if(arr[j] < arr[minIndex]){\n                    minIndex = j;\n                }\n            }\n            if(minIndex !== i){\n                let temp =  arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp; \n            }\n\n        }\n        return arr;\n    }\n\n####  插入排序\n\n    const insertSort = (arr)=>{\n        for(let i =1;i < arr.length;i++){\n            let temp  = arr[i];\n            let leftIndex = i -1;\n            while(leftIndex >=0 && arr[leftIndex] > temp){\n                arr[leftIndex + 1] = arr[leftIndex];\n                leftIndex --;\n            }\n            arr[leftIndex + 1] = temp;\n        }\n        return arr;\n        \n    }\n\n####  快速排序（填坑法）\n\n    const quickSort1 = (arr)=>{\n        const sort = (arr,startIndex,endIndex)=>{\n        //         递归结束条件：startIndex > endIndex\n                if(startIndex >= endIndex){\n                    return;\n                }\n        //         得到基准元素位置\n                let pivotIndex = partition(arr,startIndex,endIndex);\n        //         用分治法递归数列的两部分\n                sort(arr,startIndex,pivotIndex-1); \n                sort(arr,pivotIndex+1,endIndex); \n            }\n            \n            const partition = (arr,startIndex,endIndex)=>{\n        //         取第一个元素作为基准值\n                let pivot = arr[startIndex];\n                let left = startIndex;\n                let right = endIndex;\n        //         坑的位置，初始等于pivot的位置\n                let index = startIndex;\n        //         大循环在左右指针重合或者交错时结束\n                while(right >= left){\n        //             right指针从右向左进行比较\n                    while(right >=left){\n        //                 不满足条件就交换\n                        if(arr[right] < pivot){\n                            arr[left] = arr[right]\n                            index = right;\n                            left ++;\n                            break;\n                        }else{\n                            right --;\n                        }\n                    }\n        //             left指针从左向右进行比较\n                    while(right >= left){\n                        if(arr[left] > pivot){\n                            arr[right] = arr[left]\n                            index = left;\n                            right --;\n                            break;\n                        } else{\n                            left ++;\n                        }\n                        \n                    }\n                }\n                arr[index] = pivot;\n                return index;\n            }\n            \n            sort(arr,0,arr.length-1);\n            return arr;\n        }\n\n#### 快速排序（指针交换法）\n\n      const quickSort2 = (arr)=>{\n        const sort = (arr,startIndex,endIndex)=>{\n            if(startIndex >= endIndex){\n                return;\n            }\n            const partPosition = getPosition(arr,startIndex,endIndex);\n            sort(arr,startIndex,partPosition-1);\n            sort(arr,partPosition+1,endIndex);\n        }\n        \n        const getPosition = (arr,startIndex,endIndex)=>{\n            let pivot = arr[startIndex];\n            let left = startIndex;\n            let right = endIndex;\n            \n            while(right > left){\n    //             满足条件就继续\n                while (right >left  && arr[right] > pivot){\n                    right --;\n                }\n                \n              while (right >left && arr[left] <= pivot){\n                    left ++;\n                }\n              if(left < right){\n                let temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] =  temp \n                }\n                \n            }\n            \n            let temp = arr[left];\n            arr[left] = arr[startIndex];\n            arr[startIndex] =  temp;\n            return left;\n        }\n        \n        sort(arr,0,arr.length-1);\n        return arr;\n    }\n\n\n####  测试用例\n\n    // const data = [7, 6, 9, 8, 5,1];\n    const data = [7, 6, 9, 8, 5,11,14,58,32,12,41,99,65,61,18,27,34,1,2];\n      // console.log(bubbleSort([...data]));\n      // console.log(chooseSort([...data]));\n      // console.log(insertSort([...data]));\n      console.log(quickSort1([...data]));","source":"_posts/几种常用算法.md","raw":"---\ntitle: 几种常用算法\ndate: 2018-12-25 22:06:15\nupdated:\ntags:\n- 算法\nthumbnail: /images/算法/bg.jpg\n---\n####  冒泡排序\n\n    for(let i = 0; i < arr.length - 1;i++){\n        for(let j=0;j < arr.length-i-1;j++){\n            if(arr[j] > arr[j+1]){\n                let temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    return arr;\n\n####   选择排序\n\n    const chooseSort = (arr)=>{\n        for(let i =0;i < arr.length-1;i++){\n            let minIndex = i;\n            for(let j = i+1;j<arr.length;j++){\n                if(arr[j] < arr[minIndex]){\n                    minIndex = j;\n                }\n            }\n            if(minIndex !== i){\n                let temp =  arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp; \n            }\n\n        }\n        return arr;\n    }\n\n####  插入排序\n\n    const insertSort = (arr)=>{\n        for(let i =1;i < arr.length;i++){\n            let temp  = arr[i];\n            let leftIndex = i -1;\n            while(leftIndex >=0 && arr[leftIndex] > temp){\n                arr[leftIndex + 1] = arr[leftIndex];\n                leftIndex --;\n            }\n            arr[leftIndex + 1] = temp;\n        }\n        return arr;\n        \n    }\n\n####  快速排序（填坑法）\n\n    const quickSort1 = (arr)=>{\n        const sort = (arr,startIndex,endIndex)=>{\n        //         递归结束条件：startIndex > endIndex\n                if(startIndex >= endIndex){\n                    return;\n                }\n        //         得到基准元素位置\n                let pivotIndex = partition(arr,startIndex,endIndex);\n        //         用分治法递归数列的两部分\n                sort(arr,startIndex,pivotIndex-1); \n                sort(arr,pivotIndex+1,endIndex); \n            }\n            \n            const partition = (arr,startIndex,endIndex)=>{\n        //         取第一个元素作为基准值\n                let pivot = arr[startIndex];\n                let left = startIndex;\n                let right = endIndex;\n        //         坑的位置，初始等于pivot的位置\n                let index = startIndex;\n        //         大循环在左右指针重合或者交错时结束\n                while(right >= left){\n        //             right指针从右向左进行比较\n                    while(right >=left){\n        //                 不满足条件就交换\n                        if(arr[right] < pivot){\n                            arr[left] = arr[right]\n                            index = right;\n                            left ++;\n                            break;\n                        }else{\n                            right --;\n                        }\n                    }\n        //             left指针从左向右进行比较\n                    while(right >= left){\n                        if(arr[left] > pivot){\n                            arr[right] = arr[left]\n                            index = left;\n                            right --;\n                            break;\n                        } else{\n                            left ++;\n                        }\n                        \n                    }\n                }\n                arr[index] = pivot;\n                return index;\n            }\n            \n            sort(arr,0,arr.length-1);\n            return arr;\n        }\n\n#### 快速排序（指针交换法）\n\n      const quickSort2 = (arr)=>{\n        const sort = (arr,startIndex,endIndex)=>{\n            if(startIndex >= endIndex){\n                return;\n            }\n            const partPosition = getPosition(arr,startIndex,endIndex);\n            sort(arr,startIndex,partPosition-1);\n            sort(arr,partPosition+1,endIndex);\n        }\n        \n        const getPosition = (arr,startIndex,endIndex)=>{\n            let pivot = arr[startIndex];\n            let left = startIndex;\n            let right = endIndex;\n            \n            while(right > left){\n    //             满足条件就继续\n                while (right >left  && arr[right] > pivot){\n                    right --;\n                }\n                \n              while (right >left && arr[left] <= pivot){\n                    left ++;\n                }\n              if(left < right){\n                let temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] =  temp \n                }\n                \n            }\n            \n            let temp = arr[left];\n            arr[left] = arr[startIndex];\n            arr[startIndex] =  temp;\n            return left;\n        }\n        \n        sort(arr,0,arr.length-1);\n        return arr;\n    }\n\n\n####  测试用例\n\n    // const data = [7, 6, 9, 8, 5,1];\n    const data = [7, 6, 9, 8, 5,11,14,58,32,12,41,99,65,61,18,27,34,1,2];\n      // console.log(bubbleSort([...data]));\n      // console.log(chooseSort([...data]));\n      // console.log(insertSort([...data]));\n      console.log(quickSort1([...data]));","slug":"几种常用算法","published":1,"_id":"cjq4l55z00002dcha7cpctvgg","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><pre><code>for(let i = 0; i &lt; arr.length - 1;i++){\n    for(let j=0;j &lt; arr.length-i-1;j++){\n        if(arr[j] &gt; arr[j+1]){\n            let temp = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = temp;\n        }\n    }\n}\nreturn arr;\n</code></pre><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><pre><code>const chooseSort = (arr)=&gt;{\n    for(let i =0;i &lt; arr.length-1;i++){\n        let minIndex = i;\n        for(let j = i+1;j&lt;arr.length;j++){\n            if(arr[j] &lt; arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        if(minIndex !== i){\n            let temp =  arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp; \n        }\n\n    }\n    return arr;\n}\n</code></pre><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><pre><code>const insertSort = (arr)=&gt;{\n    for(let i =1;i &lt; arr.length;i++){\n        let temp  = arr[i];\n        let leftIndex = i -1;\n        while(leftIndex &gt;=0 &amp;&amp; arr[leftIndex] &gt; temp){\n            arr[leftIndex + 1] = arr[leftIndex];\n            leftIndex --;\n        }\n        arr[leftIndex + 1] = temp;\n    }\n    return arr;\n\n}\n</code></pre><h4 id=\"快速排序（填坑法）\"><a href=\"#快速排序（填坑法）\" class=\"headerlink\" title=\"快速排序（填坑法）\"></a>快速排序（填坑法）</h4><pre><code>const quickSort1 = (arr)=&gt;{\n    const sort = (arr,startIndex,endIndex)=&gt;{\n    //         递归结束条件：startIndex &gt; endIndex\n            if(startIndex &gt;= endIndex){\n                return;\n            }\n    //         得到基准元素位置\n            let pivotIndex = partition(arr,startIndex,endIndex);\n    //         用分治法递归数列的两部分\n            sort(arr,startIndex,pivotIndex-1); \n            sort(arr,pivotIndex+1,endIndex); \n        }\n\n        const partition = (arr,startIndex,endIndex)=&gt;{\n    //         取第一个元素作为基准值\n            let pivot = arr[startIndex];\n            let left = startIndex;\n            let right = endIndex;\n    //         坑的位置，初始等于pivot的位置\n            let index = startIndex;\n    //         大循环在左右指针重合或者交错时结束\n            while(right &gt;= left){\n    //             right指针从右向左进行比较\n                while(right &gt;=left){\n    //                 不满足条件就交换\n                    if(arr[right] &lt; pivot){\n                        arr[left] = arr[right]\n                        index = right;\n                        left ++;\n                        break;\n                    }else{\n                        right --;\n                    }\n                }\n    //             left指针从左向右进行比较\n                while(right &gt;= left){\n                    if(arr[left] &gt; pivot){\n                        arr[right] = arr[left]\n                        index = left;\n                        right --;\n                        break;\n                    } else{\n                        left ++;\n                    }\n\n                }\n            }\n            arr[index] = pivot;\n            return index;\n        }\n\n        sort(arr,0,arr.length-1);\n        return arr;\n    }\n</code></pre><h4 id=\"快速排序（指针交换法）\"><a href=\"#快速排序（指针交换法）\" class=\"headerlink\" title=\"快速排序（指针交换法）\"></a>快速排序（指针交换法）</h4><pre><code>  const quickSort2 = (arr)=&gt;{\n    const sort = (arr,startIndex,endIndex)=&gt;{\n        if(startIndex &gt;= endIndex){\n            return;\n        }\n        const partPosition = getPosition(arr,startIndex,endIndex);\n        sort(arr,startIndex,partPosition-1);\n        sort(arr,partPosition+1,endIndex);\n    }\n\n    const getPosition = (arr,startIndex,endIndex)=&gt;{\n        let pivot = arr[startIndex];\n        let left = startIndex;\n        let right = endIndex;\n\n        while(right &gt; left){\n//             满足条件就继续\n            while (right &gt;left  &amp;&amp; arr[right] &gt; pivot){\n                right --;\n            }\n\n          while (right &gt;left &amp;&amp; arr[left] &lt;= pivot){\n                left ++;\n            }\n          if(left &lt; right){\n            let temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] =  temp \n            }\n\n        }\n\n        let temp = arr[left];\n        arr[left] = arr[startIndex];\n        arr[startIndex] =  temp;\n        return left;\n    }\n\n    sort(arr,0,arr.length-1);\n    return arr;\n}\n</code></pre><h4 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h4><pre><code>// const data = [7, 6, 9, 8, 5,1];\nconst data = [7, 6, 9, 8, 5,11,14,58,32,12,41,99,65,61,18,27,34,1,2];\n  // console.log(bubbleSort([...data]));\n  // console.log(chooseSort([...data]));\n  // console.log(insertSort([...data]));\n  console.log(quickSort1([...data]));\n</code></pre>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><pre><code>for(let i = 0; i &lt; arr.length - 1;i++){\n    for(let j=0;j &lt; arr.length-i-1;j++){\n        if(arr[j] &gt; arr[j+1]){\n            let temp = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = temp;\n        }\n    }\n}\nreturn arr;\n</code></pre><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><pre><code>const chooseSort = (arr)=&gt;{\n    for(let i =0;i &lt; arr.length-1;i++){\n        let minIndex = i;\n        for(let j = i+1;j&lt;arr.length;j++){\n            if(arr[j] &lt; arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        if(minIndex !== i){\n            let temp =  arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp; \n        }\n\n    }\n    return arr;\n}\n</code></pre><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><pre><code>const insertSort = (arr)=&gt;{\n    for(let i =1;i &lt; arr.length;i++){\n        let temp  = arr[i];\n        let leftIndex = i -1;\n        while(leftIndex &gt;=0 &amp;&amp; arr[leftIndex] &gt; temp){\n            arr[leftIndex + 1] = arr[leftIndex];\n            leftIndex --;\n        }\n        arr[leftIndex + 1] = temp;\n    }\n    return arr;\n\n}\n</code></pre><h4 id=\"快速排序（填坑法）\"><a href=\"#快速排序（填坑法）\" class=\"headerlink\" title=\"快速排序（填坑法）\"></a>快速排序（填坑法）</h4><pre><code>const quickSort1 = (arr)=&gt;{\n    const sort = (arr,startIndex,endIndex)=&gt;{\n    //         递归结束条件：startIndex &gt; endIndex\n            if(startIndex &gt;= endIndex){\n                return;\n            }\n    //         得到基准元素位置\n            let pivotIndex = partition(arr,startIndex,endIndex);\n    //         用分治法递归数列的两部分\n            sort(arr,startIndex,pivotIndex-1); \n            sort(arr,pivotIndex+1,endIndex); \n        }\n\n        const partition = (arr,startIndex,endIndex)=&gt;{\n    //         取第一个元素作为基准值\n            let pivot = arr[startIndex];\n            let left = startIndex;\n            let right = endIndex;\n    //         坑的位置，初始等于pivot的位置\n            let index = startIndex;\n    //         大循环在左右指针重合或者交错时结束\n            while(right &gt;= left){\n    //             right指针从右向左进行比较\n                while(right &gt;=left){\n    //                 不满足条件就交换\n                    if(arr[right] &lt; pivot){\n                        arr[left] = arr[right]\n                        index = right;\n                        left ++;\n                        break;\n                    }else{\n                        right --;\n                    }\n                }\n    //             left指针从左向右进行比较\n                while(right &gt;= left){\n                    if(arr[left] &gt; pivot){\n                        arr[right] = arr[left]\n                        index = left;\n                        right --;\n                        break;\n                    } else{\n                        left ++;\n                    }\n\n                }\n            }\n            arr[index] = pivot;\n            return index;\n        }\n\n        sort(arr,0,arr.length-1);\n        return arr;\n    }\n</code></pre><h4 id=\"快速排序（指针交换法）\"><a href=\"#快速排序（指针交换法）\" class=\"headerlink\" title=\"快速排序（指针交换法）\"></a>快速排序（指针交换法）</h4><pre><code>  const quickSort2 = (arr)=&gt;{\n    const sort = (arr,startIndex,endIndex)=&gt;{\n        if(startIndex &gt;= endIndex){\n            return;\n        }\n        const partPosition = getPosition(arr,startIndex,endIndex);\n        sort(arr,startIndex,partPosition-1);\n        sort(arr,partPosition+1,endIndex);\n    }\n\n    const getPosition = (arr,startIndex,endIndex)=&gt;{\n        let pivot = arr[startIndex];\n        let left = startIndex;\n        let right = endIndex;\n\n        while(right &gt; left){\n//             满足条件就继续\n            while (right &gt;left  &amp;&amp; arr[right] &gt; pivot){\n                right --;\n            }\n\n          while (right &gt;left &amp;&amp; arr[left] &lt;= pivot){\n                left ++;\n            }\n          if(left &lt; right){\n            let temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] =  temp \n            }\n\n        }\n\n        let temp = arr[left];\n        arr[left] = arr[startIndex];\n        arr[startIndex] =  temp;\n        return left;\n    }\n\n    sort(arr,0,arr.length-1);\n    return arr;\n}\n</code></pre><h4 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h4><pre><code>// const data = [7, 6, 9, 8, 5,1];\nconst data = [7, 6, 9, 8, 5,11,14,58,32,12,41,99,65,61,18,27,34,1,2];\n  // console.log(bubbleSort([...data]));\n  // console.log(chooseSort([...data]));\n  // console.log(insertSort([...data]));\n  console.log(quickSort1([...data]));\n</code></pre>"},{"title":"动态规划，最长公共子串，最长公共子序列","date":"2018-12-26T02:22:30.000Z","updated":"2018-12-26T03:14:38.726Z","thumbnail":"/images/算法/bg.jpg","_content":"\n####  动态规划\n\n    const log = console.log.bind(this);\n    const dynamicProgramming = ()=>{\n        let cell = [];\n    //   无小数\n    //   数据排列顺序无影响\n        let priceArr = [{3:10},{1:3},{2:9},{2:5},{1:6}];\n        let spaceArr = [0,1,2,3,4,5,6];\n    //    有小数\n        // let priceArr = [{3:2000},{4:10000},{1:1500},{2:2500},{1.5:1100},{3.5:9000}];\n        // let spaceArr = [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5];\n        for(let i =0; i<priceArr.length;i++){\n            for(let j = 1;j<spaceArr.length;j++){\n                if(!cell[i]){\n                  cell[i] = [];\n                  cell[i][0] = 0;\n                }\n                let space = Object.keys(priceArr[i])[0]; //当前物件占用的空间\n                let price = priceArr[i][space]; //当前物件的价格\n                let curIndex = parseFloat(spaceArr[j]); //当前物件的索引\n                \n                if( i >= 1){ //至少有一行\n                    let lessSpace = curIndex - space; //剩余空间\n                    let lessPrice = 0; //剩余价值\n                    let curItemPirce =  0;\n                    log('............');\n                    log('lessSpace ->',lessSpace);\n                    if(lessSpace >= 0){\n                        lessPrice = cell[i-1][lessSpace] //剩余空间的价值\n                        curItemPirce = price + lessPrice; // 总共的价值\n                        log('lessPrice ->',lessPrice);\n                        log('curItemPirce ->',curItemPirce);\n                    }\n                    let prevItemPirce = cell[i-1][curIndex] //上一个格子的价值\n                    cell[i][curIndex] = Math.max(prevItemPirce,curItemPirce);\n                }else{\n                    // 大于等于空间的物品才能把价格放进去\n                    cell[i][curIndex] = curIndex >= space ? price : 0;\n                }\n\n            }\n        }\n      console.log('cell ->',cell);\n    }\n\n####  计算最长公共子串\n\n      const computeTheLongestString = (inputValue,compareValue)=>{\n          let inputArr = inputValue.split('');\n          let compareArr = compareValue.split('');\n          let result = [];\n          let maxValue = 0;\n          for(let i = 0;i < inputArr.length;i++){\n              for(let j = 0; j<compareArr.length;j++){\n                  if(!result[i]){\n                      result[i] = [];\n                  }\n                \n                  if(inputArr[i] === compareArr[j]){\n                      if(i>0 && j>0){\n                          result[i][j] = result[i-1][j-1] + 1;\n                      }else{\n                          result[i][j] = 1;\n                      }\n                      maxValue = Math.max(maxValue,result[i][j]);\n                  }else{\n                      result[i][j] = 0;\n                  }\n              }\n          }\n          log('result ->',result);\n          log('maxValue ->',maxValue);\n      }\n\n      // computeTheLongestString('hish','fish');\n      // computeTheLongestString('hish','vista');\n\n####  计算出最长公共子序列\n\n    const computingTheLongestSubsequence = (inputValue,compareValue)=>{\n        let inputArr = inputValue.split('');\n        let compareArr = compareValue.split('');\n        let result = [];\n        let maxValue = 0;\n        for(let i = 0;i < inputArr.length;i++){\n            for(let j = 0; j<compareArr.length;j++){\n                if(!result[i]){\n                    result[i] = [];\n                }\n              \n                if(inputArr[i] === compareArr[j]){\n                    if(i>0 && j>0){\n                        result[i][j] = result[i-1][j-1] + 1;\n                    }else{\n                        result[i][j] = 1; \n                    }\n                }else{\n                    result[i][j] = Math.max(i > 0 ? result[i-1][j]:0,j > 0 ?result[i][j-1]:0)\n                }\n            }\n        }\n        maxValue = result[result.length-1][result[0].length-1];\n        log('result ->',result);\n        log('maxValue ->',maxValue);\n    }\n\n\n    computingTheLongestSubsequence('fish','fosh');\n    computingTheLongestSubsequence('fort','fosh');","source":"_posts/动态规划，最长公共子串，最长公共子序列.md","raw":"---\ntitle: 动态规划，最长公共子串，最长公共子序列\ndate: 2018-12-26 10:22:30\nupdated:\ntags:\n- 动态规划\n- 最长公共子串\n- 最长公共子序列\nthumbnail: /images/算法/bg.jpg\n---\n\n####  动态规划\n\n    const log = console.log.bind(this);\n    const dynamicProgramming = ()=>{\n        let cell = [];\n    //   无小数\n    //   数据排列顺序无影响\n        let priceArr = [{3:10},{1:3},{2:9},{2:5},{1:6}];\n        let spaceArr = [0,1,2,3,4,5,6];\n    //    有小数\n        // let priceArr = [{3:2000},{4:10000},{1:1500},{2:2500},{1.5:1100},{3.5:9000}];\n        // let spaceArr = [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5];\n        for(let i =0; i<priceArr.length;i++){\n            for(let j = 1;j<spaceArr.length;j++){\n                if(!cell[i]){\n                  cell[i] = [];\n                  cell[i][0] = 0;\n                }\n                let space = Object.keys(priceArr[i])[0]; //当前物件占用的空间\n                let price = priceArr[i][space]; //当前物件的价格\n                let curIndex = parseFloat(spaceArr[j]); //当前物件的索引\n                \n                if( i >= 1){ //至少有一行\n                    let lessSpace = curIndex - space; //剩余空间\n                    let lessPrice = 0; //剩余价值\n                    let curItemPirce =  0;\n                    log('............');\n                    log('lessSpace ->',lessSpace);\n                    if(lessSpace >= 0){\n                        lessPrice = cell[i-1][lessSpace] //剩余空间的价值\n                        curItemPirce = price + lessPrice; // 总共的价值\n                        log('lessPrice ->',lessPrice);\n                        log('curItemPirce ->',curItemPirce);\n                    }\n                    let prevItemPirce = cell[i-1][curIndex] //上一个格子的价值\n                    cell[i][curIndex] = Math.max(prevItemPirce,curItemPirce);\n                }else{\n                    // 大于等于空间的物品才能把价格放进去\n                    cell[i][curIndex] = curIndex >= space ? price : 0;\n                }\n\n            }\n        }\n      console.log('cell ->',cell);\n    }\n\n####  计算最长公共子串\n\n      const computeTheLongestString = (inputValue,compareValue)=>{\n          let inputArr = inputValue.split('');\n          let compareArr = compareValue.split('');\n          let result = [];\n          let maxValue = 0;\n          for(let i = 0;i < inputArr.length;i++){\n              for(let j = 0; j<compareArr.length;j++){\n                  if(!result[i]){\n                      result[i] = [];\n                  }\n                \n                  if(inputArr[i] === compareArr[j]){\n                      if(i>0 && j>0){\n                          result[i][j] = result[i-1][j-1] + 1;\n                      }else{\n                          result[i][j] = 1;\n                      }\n                      maxValue = Math.max(maxValue,result[i][j]);\n                  }else{\n                      result[i][j] = 0;\n                  }\n              }\n          }\n          log('result ->',result);\n          log('maxValue ->',maxValue);\n      }\n\n      // computeTheLongestString('hish','fish');\n      // computeTheLongestString('hish','vista');\n\n####  计算出最长公共子序列\n\n    const computingTheLongestSubsequence = (inputValue,compareValue)=>{\n        let inputArr = inputValue.split('');\n        let compareArr = compareValue.split('');\n        let result = [];\n        let maxValue = 0;\n        for(let i = 0;i < inputArr.length;i++){\n            for(let j = 0; j<compareArr.length;j++){\n                if(!result[i]){\n                    result[i] = [];\n                }\n              \n                if(inputArr[i] === compareArr[j]){\n                    if(i>0 && j>0){\n                        result[i][j] = result[i-1][j-1] + 1;\n                    }else{\n                        result[i][j] = 1; \n                    }\n                }else{\n                    result[i][j] = Math.max(i > 0 ? result[i-1][j]:0,j > 0 ?result[i][j-1]:0)\n                }\n            }\n        }\n        maxValue = result[result.length-1][result[0].length-1];\n        log('result ->',result);\n        log('maxValue ->',maxValue);\n    }\n\n\n    computingTheLongestSubsequence('fish','fosh');\n    computingTheLongestSubsequence('fort','fosh');","slug":"动态规划，最长公共子串，最长公共子序列","published":1,"_id":"cjq4l55z40003dchaej75zjhg","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><pre><code>const log = console.log.bind(this);\nconst dynamicProgramming = ()=&gt;{\n    let cell = [];\n//   无小数\n//   数据排列顺序无影响\n    let priceArr = [{3:10},{1:3},{2:9},{2:5},{1:6}];\n    let spaceArr = [0,1,2,3,4,5,6];\n//    有小数\n    // let priceArr = [{3:2000},{4:10000},{1:1500},{2:2500},{1.5:1100},{3.5:9000}];\n    // let spaceArr = [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5];\n    for(let i =0; i&lt;priceArr.length;i++){\n        for(let j = 1;j&lt;spaceArr.length;j++){\n            if(!cell[i]){\n              cell[i] = [];\n              cell[i][0] = 0;\n            }\n            let space = Object.keys(priceArr[i])[0]; //当前物件占用的空间\n            let price = priceArr[i][space]; //当前物件的价格\n            let curIndex = parseFloat(spaceArr[j]); //当前物件的索引\n\n            if( i &gt;= 1){ //至少有一行\n                let lessSpace = curIndex - space; //剩余空间\n                let lessPrice = 0; //剩余价值\n                let curItemPirce =  0;\n                log(&apos;............&apos;);\n                log(&apos;lessSpace -&gt;&apos;,lessSpace);\n                if(lessSpace &gt;= 0){\n                    lessPrice = cell[i-1][lessSpace] //剩余空间的价值\n                    curItemPirce = price + lessPrice; // 总共的价值\n                    log(&apos;lessPrice -&gt;&apos;,lessPrice);\n                    log(&apos;curItemPirce -&gt;&apos;,curItemPirce);\n                }\n                let prevItemPirce = cell[i-1][curIndex] //上一个格子的价值\n                cell[i][curIndex] = Math.max(prevItemPirce,curItemPirce);\n            }else{\n                // 大于等于空间的物品才能把价格放进去\n                cell[i][curIndex] = curIndex &gt;= space ? price : 0;\n            }\n\n        }\n    }\n  console.log(&apos;cell -&gt;&apos;,cell);\n}\n</code></pre><h4 id=\"计算最长公共子串\"><a href=\"#计算最长公共子串\" class=\"headerlink\" title=\"计算最长公共子串\"></a>计算最长公共子串</h4><pre><code>const computeTheLongestString = (inputValue,compareValue)=&gt;{\n    let inputArr = inputValue.split(&apos;&apos;);\n    let compareArr = compareValue.split(&apos;&apos;);\n    let result = [];\n    let maxValue = 0;\n    for(let i = 0;i &lt; inputArr.length;i++){\n        for(let j = 0; j&lt;compareArr.length;j++){\n            if(!result[i]){\n                result[i] = [];\n            }\n\n            if(inputArr[i] === compareArr[j]){\n                if(i&gt;0 &amp;&amp; j&gt;0){\n                    result[i][j] = result[i-1][j-1] + 1;\n                }else{\n                    result[i][j] = 1;\n                }\n                maxValue = Math.max(maxValue,result[i][j]);\n            }else{\n                result[i][j] = 0;\n            }\n        }\n    }\n    log(&apos;result -&gt;&apos;,result);\n    log(&apos;maxValue -&gt;&apos;,maxValue);\n}\n\n// computeTheLongestString(&apos;hish&apos;,&apos;fish&apos;);\n// computeTheLongestString(&apos;hish&apos;,&apos;vista&apos;);\n</code></pre><h4 id=\"计算出最长公共子序列\"><a href=\"#计算出最长公共子序列\" class=\"headerlink\" title=\"计算出最长公共子序列\"></a>计算出最长公共子序列</h4><pre><code>const computingTheLongestSubsequence = (inputValue,compareValue)=&gt;{\n    let inputArr = inputValue.split(&apos;&apos;);\n    let compareArr = compareValue.split(&apos;&apos;);\n    let result = [];\n    let maxValue = 0;\n    for(let i = 0;i &lt; inputArr.length;i++){\n        for(let j = 0; j&lt;compareArr.length;j++){\n            if(!result[i]){\n                result[i] = [];\n            }\n\n            if(inputArr[i] === compareArr[j]){\n                if(i&gt;0 &amp;&amp; j&gt;0){\n                    result[i][j] = result[i-1][j-1] + 1;\n                }else{\n                    result[i][j] = 1; \n                }\n            }else{\n                result[i][j] = Math.max(i &gt; 0 ? result[i-1][j]:0,j &gt; 0 ?result[i][j-1]:0)\n            }\n        }\n    }\n    maxValue = result[result.length-1][result[0].length-1];\n    log(&apos;result -&gt;&apos;,result);\n    log(&apos;maxValue -&gt;&apos;,maxValue);\n}\n\n\ncomputingTheLongestSubsequence(&apos;fish&apos;,&apos;fosh&apos;);\ncomputingTheLongestSubsequence(&apos;fort&apos;,&apos;fosh&apos;);\n</code></pre>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><pre><code>const log = console.log.bind(this);\nconst dynamicProgramming = ()=&gt;{\n    let cell = [];\n//   无小数\n//   数据排列顺序无影响\n    let priceArr = [{3:10},{1:3},{2:9},{2:5},{1:6}];\n    let spaceArr = [0,1,2,3,4,5,6];\n//    有小数\n    // let priceArr = [{3:2000},{4:10000},{1:1500},{2:2500},{1.5:1100},{3.5:9000}];\n    // let spaceArr = [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5];\n    for(let i =0; i&lt;priceArr.length;i++){\n        for(let j = 1;j&lt;spaceArr.length;j++){\n            if(!cell[i]){\n              cell[i] = [];\n              cell[i][0] = 0;\n            }\n            let space = Object.keys(priceArr[i])[0]; //当前物件占用的空间\n            let price = priceArr[i][space]; //当前物件的价格\n            let curIndex = parseFloat(spaceArr[j]); //当前物件的索引\n\n            if( i &gt;= 1){ //至少有一行\n                let lessSpace = curIndex - space; //剩余空间\n                let lessPrice = 0; //剩余价值\n                let curItemPirce =  0;\n                log(&apos;............&apos;);\n                log(&apos;lessSpace -&gt;&apos;,lessSpace);\n                if(lessSpace &gt;= 0){\n                    lessPrice = cell[i-1][lessSpace] //剩余空间的价值\n                    curItemPirce = price + lessPrice; // 总共的价值\n                    log(&apos;lessPrice -&gt;&apos;,lessPrice);\n                    log(&apos;curItemPirce -&gt;&apos;,curItemPirce);\n                }\n                let prevItemPirce = cell[i-1][curIndex] //上一个格子的价值\n                cell[i][curIndex] = Math.max(prevItemPirce,curItemPirce);\n            }else{\n                // 大于等于空间的物品才能把价格放进去\n                cell[i][curIndex] = curIndex &gt;= space ? price : 0;\n            }\n\n        }\n    }\n  console.log(&apos;cell -&gt;&apos;,cell);\n}\n</code></pre><h4 id=\"计算最长公共子串\"><a href=\"#计算最长公共子串\" class=\"headerlink\" title=\"计算最长公共子串\"></a>计算最长公共子串</h4><pre><code>const computeTheLongestString = (inputValue,compareValue)=&gt;{\n    let inputArr = inputValue.split(&apos;&apos;);\n    let compareArr = compareValue.split(&apos;&apos;);\n    let result = [];\n    let maxValue = 0;\n    for(let i = 0;i &lt; inputArr.length;i++){\n        for(let j = 0; j&lt;compareArr.length;j++){\n            if(!result[i]){\n                result[i] = [];\n            }\n\n            if(inputArr[i] === compareArr[j]){\n                if(i&gt;0 &amp;&amp; j&gt;0){\n                    result[i][j] = result[i-1][j-1] + 1;\n                }else{\n                    result[i][j] = 1;\n                }\n                maxValue = Math.max(maxValue,result[i][j]);\n            }else{\n                result[i][j] = 0;\n            }\n        }\n    }\n    log(&apos;result -&gt;&apos;,result);\n    log(&apos;maxValue -&gt;&apos;,maxValue);\n}\n\n// computeTheLongestString(&apos;hish&apos;,&apos;fish&apos;);\n// computeTheLongestString(&apos;hish&apos;,&apos;vista&apos;);\n</code></pre><h4 id=\"计算出最长公共子序列\"><a href=\"#计算出最长公共子序列\" class=\"headerlink\" title=\"计算出最长公共子序列\"></a>计算出最长公共子序列</h4><pre><code>const computingTheLongestSubsequence = (inputValue,compareValue)=&gt;{\n    let inputArr = inputValue.split(&apos;&apos;);\n    let compareArr = compareValue.split(&apos;&apos;);\n    let result = [];\n    let maxValue = 0;\n    for(let i = 0;i &lt; inputArr.length;i++){\n        for(let j = 0; j&lt;compareArr.length;j++){\n            if(!result[i]){\n                result[i] = [];\n            }\n\n            if(inputArr[i] === compareArr[j]){\n                if(i&gt;0 &amp;&amp; j&gt;0){\n                    result[i][j] = result[i-1][j-1] + 1;\n                }else{\n                    result[i][j] = 1; \n                }\n            }else{\n                result[i][j] = Math.max(i &gt; 0 ? result[i-1][j]:0,j &gt; 0 ?result[i][j-1]:0)\n            }\n        }\n    }\n    maxValue = result[result.length-1][result[0].length-1];\n    log(&apos;result -&gt;&apos;,result);\n    log(&apos;maxValue -&gt;&apos;,maxValue);\n}\n\n\ncomputingTheLongestSubsequence(&apos;fish&apos;,&apos;fosh&apos;);\ncomputingTheLongestSubsequence(&apos;fort&apos;,&apos;fosh&apos;);\n</code></pre>"},{"title":"Hello Hexo !","date":"2017-11-26T09:07:50.000Z","thumbnail":"/images/将hexo配置到github上/bg.png","_content":"# 自己用Hexo搭建一个博客！\n>  您需要掌握以下的技术 :\ngit hexo hexo主题 markdown \n\n### 一些文档链接\n[hexo](https://hexo.io/zh-cn/docs/)\n[hexo-theme-material](https://github.com/viosey/hexo-theme-material)\n[hexo-theme-one](https://github.com/EYHN/hexo-theme-one)\n[markdown](http://wowubuntu.com/markdown/basic.html)\n\n### 祝你自己也能搭建一个有个人特色的博客! ","source":"_posts/Hello-Hexo.md","raw":"---\ntitle: Hello Hexo !\ndate: 2017-11-26 17:07:50\ncategories:\n- 项目\ntags:\n- Hexo\n- 介绍\nthumbnail: /images/将hexo配置到github上/bg.png\n---\n# 自己用Hexo搭建一个博客！\n>  您需要掌握以下的技术 :\ngit hexo hexo主题 markdown \n\n### 一些文档链接\n[hexo](https://hexo.io/zh-cn/docs/)\n[hexo-theme-material](https://github.com/viosey/hexo-theme-material)\n[hexo-theme-one](https://github.com/EYHN/hexo-theme-one)\n[markdown](http://wowubuntu.com/markdown/basic.html)\n\n### 祝你自己也能搭建一个有个人特色的博客! ","slug":"Hello-Hexo","published":1,"updated":"2018-12-26T03:14:41.766Z","_id":"cjq4l55z90005dchahsjqno8m","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"自己用Hexo搭建一个博客！\"><a href=\"#自己用Hexo搭建一个博客！\" class=\"headerlink\" title=\"自己用Hexo搭建一个博客！\"></a>自己用Hexo搭建一个博客！</h1><blockquote>\n<p> 您需要掌握以下的技术 :<br>git hexo hexo主题 markdown </p>\n</blockquote>\n<h3 id=\"一些文档链接\"><a href=\"#一些文档链接\" class=\"headerlink\" title=\"一些文档链接\"></a>一些文档链接</h3><p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">hexo</a><br><a href=\"https://github.com/viosey/hexo-theme-material\" target=\"_blank\" rel=\"noopener\">hexo-theme-material</a><br><a href=\"https://github.com/EYHN/hexo-theme-one\" target=\"_blank\" rel=\"noopener\">hexo-theme-one</a><br><a href=\"http://wowubuntu.com/markdown/basic.html\" target=\"_blank\" rel=\"noopener\">markdown</a></p>\n<h3 id=\"祝你自己也能搭建一个有个人特色的博客\"><a href=\"#祝你自己也能搭建一个有个人特色的博客\" class=\"headerlink\" title=\"祝你自己也能搭建一个有个人特色的博客!\"></a>祝你自己也能搭建一个有个人特色的博客!</h3>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h1 id=\"自己用Hexo搭建一个博客！\"><a href=\"#自己用Hexo搭建一个博客！\" class=\"headerlink\" title=\"自己用Hexo搭建一个博客！\"></a>自己用Hexo搭建一个博客！</h1><blockquote>\n<p> 您需要掌握以下的技术 :<br>git hexo hexo主题 markdown </p>\n</blockquote>\n<h3 id=\"一些文档链接\"><a href=\"#一些文档链接\" class=\"headerlink\" title=\"一些文档链接\"></a>一些文档链接</h3><p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">hexo</a><br><a href=\"https://github.com/viosey/hexo-theme-material\" target=\"_blank\" rel=\"noopener\">hexo-theme-material</a><br><a href=\"https://github.com/EYHN/hexo-theme-one\" target=\"_blank\" rel=\"noopener\">hexo-theme-one</a><br><a href=\"http://wowubuntu.com/markdown/basic.html\" target=\"_blank\" rel=\"noopener\">markdown</a></p>\n<h3 id=\"祝你自己也能搭建一个有个人特色的博客\"><a href=\"#祝你自己也能搭建一个有个人特色的博客\" class=\"headerlink\" title=\"祝你自己也能搭建一个有个人特色的博客!\"></a>祝你自己也能搭建一个有个人特色的博客!</h3>"},{"title":"K最近邻算法","date":"2018-12-26T02:12:47.000Z","updated":"2018-12-26T03:14:29.602Z","thumbnail":"/images/算法/bg.jpg","_content":"####  K最近邻算法\n\n    //漫画算法图解 P163页\n    // 求估计最近4天卖出面包的数量\n    const log = console.log.bind(this);\n\n      const algorithm = (originData,testData)=>{\n          let result = [];\n          let value = [];\n          for(let item of testData){\n              for(let key in item){\n                  value.push(calculateSimilarNumber(key,originData) );\n                  result.push(item[key])\n              }\n            \n          }\n          let limitNum = 4;\n          let sortArr = bubbleSort(value);\n          sortArr = sortArr.splice(0,limitNum);\n          let totalNum = sortArr.reduce((total,index)=>{\n              return total + result[index];\n          },0)\n          // log('totalNum ->',totalNum);\n          //  log('value ->',value);\n          //  log('result ->',result);\n          //  log('sortArr ->',sortArr);\n          let averageNum = totalNum / limitNum;\n          // log('averageNum ->',averageNum);\n          return averageNum\n      }\n          \n      const calculateSimilarNumber = (compareData,originData)=>{\n          let result = 0;\n          if(compareData.length && originData.length){\n              let compareDataArr = compareData.split(',');\n              let originDataArr = originData.split(',');\n              for(let i =0;i < compareDataArr.length;i++){\n                  result += Math.pow(compareDataArr[i] - originDataArr[i],2);\n              }\n              result = Math.round(Math.sqrt(result) * 100) / 100;\n          }\n          \n          return result;\n      }\n\n      const bubbleSort = (originArr)=>{\n          let arr = [...originArr];\n          let sortArr = [];\n          for(let i =0;i <arr.length;i++ ){\n              sortArr.push(i);\n          }\n          for(let i = 0; i < arr.length - 1;i++){\n              for(let j=0;j < arr.length-i-1;j++){\n                  if(arr[j] > arr[j+1]){\n                      let temp = arr[j];\n                      arr[j] = arr[j+1];\n                      arr[j+1] = temp;\n                      \n                      let temp2 = sortArr[j];\n                      sortArr[j] = sortArr[j+1];\n                      sortArr[j+1] = temp2;\n                  }\n              }\n          }\n          return sortArr;\n      }\n\n      const testData = [\n          {\n              '5,1,0':300\n          },\n          {\n              '3,1,1':225\n          },\n          {\n              '1,1,0':75\n          },\n          {\n              '4,0,1':200\n          },\n          {\n              '4,0,0':150\n          },\n          {\n              '2,0,0':50\n          }\n      ]\n\n      const originData = '4,1,0';\n\n      algorithm(originData,testData);\n","source":"_posts/K最近邻算法.md","raw":"---\ntitle: K最近邻算法\ndate: 2018-12-26 10:12:47\nupdated:\ntags:\n- 算法\n- K最近邻算法\nthumbnail: /images/算法/bg.jpg\n---\n####  K最近邻算法\n\n    //漫画算法图解 P163页\n    // 求估计最近4天卖出面包的数量\n    const log = console.log.bind(this);\n\n      const algorithm = (originData,testData)=>{\n          let result = [];\n          let value = [];\n          for(let item of testData){\n              for(let key in item){\n                  value.push(calculateSimilarNumber(key,originData) );\n                  result.push(item[key])\n              }\n            \n          }\n          let limitNum = 4;\n          let sortArr = bubbleSort(value);\n          sortArr = sortArr.splice(0,limitNum);\n          let totalNum = sortArr.reduce((total,index)=>{\n              return total + result[index];\n          },0)\n          // log('totalNum ->',totalNum);\n          //  log('value ->',value);\n          //  log('result ->',result);\n          //  log('sortArr ->',sortArr);\n          let averageNum = totalNum / limitNum;\n          // log('averageNum ->',averageNum);\n          return averageNum\n      }\n          \n      const calculateSimilarNumber = (compareData,originData)=>{\n          let result = 0;\n          if(compareData.length && originData.length){\n              let compareDataArr = compareData.split(',');\n              let originDataArr = originData.split(',');\n              for(let i =0;i < compareDataArr.length;i++){\n                  result += Math.pow(compareDataArr[i] - originDataArr[i],2);\n              }\n              result = Math.round(Math.sqrt(result) * 100) / 100;\n          }\n          \n          return result;\n      }\n\n      const bubbleSort = (originArr)=>{\n          let arr = [...originArr];\n          let sortArr = [];\n          for(let i =0;i <arr.length;i++ ){\n              sortArr.push(i);\n          }\n          for(let i = 0; i < arr.length - 1;i++){\n              for(let j=0;j < arr.length-i-1;j++){\n                  if(arr[j] > arr[j+1]){\n                      let temp = arr[j];\n                      arr[j] = arr[j+1];\n                      arr[j+1] = temp;\n                      \n                      let temp2 = sortArr[j];\n                      sortArr[j] = sortArr[j+1];\n                      sortArr[j+1] = temp2;\n                  }\n              }\n          }\n          return sortArr;\n      }\n\n      const testData = [\n          {\n              '5,1,0':300\n          },\n          {\n              '3,1,1':225\n          },\n          {\n              '1,1,0':75\n          },\n          {\n              '4,0,1':200\n          },\n          {\n              '4,0,0':150\n          },\n          {\n              '2,0,0':50\n          }\n      ]\n\n      const originData = '4,1,0';\n\n      algorithm(originData,testData);\n","slug":"K最近邻算法","published":1,"_id":"cjq4l55zb0006dcha3lqcxvys","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"K最近邻算法\"><a href=\"#K最近邻算法\" class=\"headerlink\" title=\"K最近邻算法\"></a>K最近邻算法</h4><pre><code>//漫画算法图解 P163页\n// 求估计最近4天卖出面包的数量\nconst log = console.log.bind(this);\n\n  const algorithm = (originData,testData)=&gt;{\n      let result = [];\n      let value = [];\n      for(let item of testData){\n          for(let key in item){\n              value.push(calculateSimilarNumber(key,originData) );\n              result.push(item[key])\n          }\n\n      }\n      let limitNum = 4;\n      let sortArr = bubbleSort(value);\n      sortArr = sortArr.splice(0,limitNum);\n      let totalNum = sortArr.reduce((total,index)=&gt;{\n          return total + result[index];\n      },0)\n      // log(&apos;totalNum -&gt;&apos;,totalNum);\n      //  log(&apos;value -&gt;&apos;,value);\n      //  log(&apos;result -&gt;&apos;,result);\n      //  log(&apos;sortArr -&gt;&apos;,sortArr);\n      let averageNum = totalNum / limitNum;\n      // log(&apos;averageNum -&gt;&apos;,averageNum);\n      return averageNum\n  }\n\n  const calculateSimilarNumber = (compareData,originData)=&gt;{\n      let result = 0;\n      if(compareData.length &amp;&amp; originData.length){\n          let compareDataArr = compareData.split(&apos;,&apos;);\n          let originDataArr = originData.split(&apos;,&apos;);\n          for(let i =0;i &lt; compareDataArr.length;i++){\n              result += Math.pow(compareDataArr[i] - originDataArr[i],2);\n          }\n          result = Math.round(Math.sqrt(result) * 100) / 100;\n      }\n\n      return result;\n  }\n\n  const bubbleSort = (originArr)=&gt;{\n      let arr = [...originArr];\n      let sortArr = [];\n      for(let i =0;i &lt;arr.length;i++ ){\n          sortArr.push(i);\n      }\n      for(let i = 0; i &lt; arr.length - 1;i++){\n          for(let j=0;j &lt; arr.length-i-1;j++){\n              if(arr[j] &gt; arr[j+1]){\n                  let temp = arr[j];\n                  arr[j] = arr[j+1];\n                  arr[j+1] = temp;\n\n                  let temp2 = sortArr[j];\n                  sortArr[j] = sortArr[j+1];\n                  sortArr[j+1] = temp2;\n              }\n          }\n      }\n      return sortArr;\n  }\n\n  const testData = [\n      {\n          &apos;5,1,0&apos;:300\n      },\n      {\n          &apos;3,1,1&apos;:225\n      },\n      {\n          &apos;1,1,0&apos;:75\n      },\n      {\n          &apos;4,0,1&apos;:200\n      },\n      {\n          &apos;4,0,0&apos;:150\n      },\n      {\n          &apos;2,0,0&apos;:50\n      }\n  ]\n\n  const originData = &apos;4,1,0&apos;;\n\n  algorithm(originData,testData);\n</code></pre>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h4 id=\"K最近邻算法\"><a href=\"#K最近邻算法\" class=\"headerlink\" title=\"K最近邻算法\"></a>K最近邻算法</h4><pre><code>//漫画算法图解 P163页\n// 求估计最近4天卖出面包的数量\nconst log = console.log.bind(this);\n\n  const algorithm = (originData,testData)=&gt;{\n      let result = [];\n      let value = [];\n      for(let item of testData){\n          for(let key in item){\n              value.push(calculateSimilarNumber(key,originData) );\n              result.push(item[key])\n          }\n\n      }\n      let limitNum = 4;\n      let sortArr = bubbleSort(value);\n      sortArr = sortArr.splice(0,limitNum);\n      let totalNum = sortArr.reduce((total,index)=&gt;{\n          return total + result[index];\n      },0)\n      // log(&apos;totalNum -&gt;&apos;,totalNum);\n      //  log(&apos;value -&gt;&apos;,value);\n      //  log(&apos;result -&gt;&apos;,result);\n      //  log(&apos;sortArr -&gt;&apos;,sortArr);\n      let averageNum = totalNum / limitNum;\n      // log(&apos;averageNum -&gt;&apos;,averageNum);\n      return averageNum\n  }\n\n  const calculateSimilarNumber = (compareData,originData)=&gt;{\n      let result = 0;\n      if(compareData.length &amp;&amp; originData.length){\n          let compareDataArr = compareData.split(&apos;,&apos;);\n          let originDataArr = originData.split(&apos;,&apos;);\n          for(let i =0;i &lt; compareDataArr.length;i++){\n              result += Math.pow(compareDataArr[i] - originDataArr[i],2);\n          }\n          result = Math.round(Math.sqrt(result) * 100) / 100;\n      }\n\n      return result;\n  }\n\n  const bubbleSort = (originArr)=&gt;{\n      let arr = [...originArr];\n      let sortArr = [];\n      for(let i =0;i &lt;arr.length;i++ ){\n          sortArr.push(i);\n      }\n      for(let i = 0; i &lt; arr.length - 1;i++){\n          for(let j=0;j &lt; arr.length-i-1;j++){\n              if(arr[j] &gt; arr[j+1]){\n                  let temp = arr[j];\n                  arr[j] = arr[j+1];\n                  arr[j+1] = temp;\n\n                  let temp2 = sortArr[j];\n                  sortArr[j] = sortArr[j+1];\n                  sortArr[j+1] = temp2;\n              }\n          }\n      }\n      return sortArr;\n  }\n\n  const testData = [\n      {\n          &apos;5,1,0&apos;:300\n      },\n      {\n          &apos;3,1,1&apos;:225\n      },\n      {\n          &apos;1,1,0&apos;:75\n      },\n      {\n          &apos;4,0,1&apos;:200\n      },\n      {\n          &apos;4,0,0&apos;:150\n      },\n      {\n          &apos;2,0,0&apos;:50\n      }\n  ]\n\n  const originData = &apos;4,1,0&apos;;\n\n  algorithm(originData,testData);\n</code></pre>"},{"title":"贪婪算法之近似算法（广播集合覆盖问题）","date":"2018-12-26T02:16:57.000Z","updated":"2018-12-26T03:14:24.554Z","thumbnail":"/images/算法/bg.jpg","_content":"#### 概念\n\n* 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。\n\n* 贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果：\n  * 贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。\n\n  * 必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。\n\n  * 广度优先、狄克斯特拉算法，近似算法,动态规划,只是在其问题策略的选择上，刚好可以得到最优解。\n\n* 判断近似算法的优劣标准如下:\n  * 速度有多快\n  * 得到的近似解与最优解的接近程度\n\n####  案例:广播集合覆盖问题\n\n      const log = console.log.bind(this);\n      const test = ()=>{\n          let states = {};\n          states['kone'] = ['id','nv','ut']\n          states['ktwo'] = ['wa','id','mt']\n          states['kthree'] = ['or','nv','ca']\n          states['kfour'] = ['nv','ut']\n          states['kfive'] = ['ca','az']\n          \n          let statesNeeded = ['id','nv','ut','wa','ca','mt','or','az'];\n          let bestStation = [];\n          let statesCovered = [];//所有未覆盖的州\n          let couvered = [];//包含当前光比太覆盖一系列未覆盖的州\n          let finalStation = [];//最后的集合\n          \n          while(statesNeeded.length){\n                statesCovered = [];\n                bestStation = [];\n                for(let state in states){\n                    couvered = getTheRepeatArr(states[state],statesNeeded);\n                    log('couvered ->',couvered);\n                    log('statesCovered ->',statesCovered);\n                    //判断未覆盖州中取最大的\n                    if(couvered.length > statesCovered.length){\n                        bestStation = state;\n                        statesCovered = couvered;\n                    }\n                }\n              log('statesCovered ->',statesCovered);\n              statesNeeded = removeTheRepeatArr(statesNeeded,statesCovered)\n              log('statesNeeded ->',statesNeeded);\n              log('bestStation ->',bestStation);\n              log('-------------->');\n              finalStation.push(bestStation);\n            }\n          return finalStation;\n      }\n          \n          //获得重复的数组元素\n          const getTheRepeatArr = (arr1,arr2)=>{\n              let obj = {};\n              let repeatArr = [];\n              for(let item of arr1){\n                  obj[item] = 1;\n              }\n              for(let item of arr2){\n                  if(obj[item]){\n                      obj[item] = 2;\n                      repeatArr.push(item);\n                  }else{\n                      obj[item] = 1;\n                  }\n              }\n              return repeatArr;\n          }\n          \n          //除去bigArr中的repeatArr中的元素\n          const removeTheRepeatArr = (bigArr,repeatArr)=>{\n              let obj = {};\n              for(let item of repeatArr){\n                  obj[item] = 1;\n              }\n              \n              for(let i=0;i < bigArr.length;i++){\n                  if(obj[bigArr[i]]){\n                      bigArr.splice(i,1);\n                      i--;\n                  }\n              }\n              return bigArr;\n          }\n          \n          \n          // let arr1 = ['id','nv','ut','wa','ca'];\n          // let arr2 = ['id','nv','ut','mt','or','az'];\n          // let result = removeTheRepeatArr(arr2,arr1);\n          // console.log('result ->',result);\n          let result = test();\n          log('result ->',result)\n","source":"_posts/贪婪算法之近似算法（广播集合覆盖问题）.md","raw":"---\ntitle: 贪婪算法之近似算法（广播集合覆盖问题）\ndate: 2018-12-26 10:16:57\nupdated:\ntags:\n- 贪婪算法\nthumbnail: /images/算法/bg.jpg\n---\n#### 概念\n\n* 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。\n\n* 贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果：\n  * 贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。\n\n  * 必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。\n\n  * 广度优先、狄克斯特拉算法，近似算法,动态规划,只是在其问题策略的选择上，刚好可以得到最优解。\n\n* 判断近似算法的优劣标准如下:\n  * 速度有多快\n  * 得到的近似解与最优解的接近程度\n\n####  案例:广播集合覆盖问题\n\n      const log = console.log.bind(this);\n      const test = ()=>{\n          let states = {};\n          states['kone'] = ['id','nv','ut']\n          states['ktwo'] = ['wa','id','mt']\n          states['kthree'] = ['or','nv','ca']\n          states['kfour'] = ['nv','ut']\n          states['kfive'] = ['ca','az']\n          \n          let statesNeeded = ['id','nv','ut','wa','ca','mt','or','az'];\n          let bestStation = [];\n          let statesCovered = [];//所有未覆盖的州\n          let couvered = [];//包含当前光比太覆盖一系列未覆盖的州\n          let finalStation = [];//最后的集合\n          \n          while(statesNeeded.length){\n                statesCovered = [];\n                bestStation = [];\n                for(let state in states){\n                    couvered = getTheRepeatArr(states[state],statesNeeded);\n                    log('couvered ->',couvered);\n                    log('statesCovered ->',statesCovered);\n                    //判断未覆盖州中取最大的\n                    if(couvered.length > statesCovered.length){\n                        bestStation = state;\n                        statesCovered = couvered;\n                    }\n                }\n              log('statesCovered ->',statesCovered);\n              statesNeeded = removeTheRepeatArr(statesNeeded,statesCovered)\n              log('statesNeeded ->',statesNeeded);\n              log('bestStation ->',bestStation);\n              log('-------------->');\n              finalStation.push(bestStation);\n            }\n          return finalStation;\n      }\n          \n          //获得重复的数组元素\n          const getTheRepeatArr = (arr1,arr2)=>{\n              let obj = {};\n              let repeatArr = [];\n              for(let item of arr1){\n                  obj[item] = 1;\n              }\n              for(let item of arr2){\n                  if(obj[item]){\n                      obj[item] = 2;\n                      repeatArr.push(item);\n                  }else{\n                      obj[item] = 1;\n                  }\n              }\n              return repeatArr;\n          }\n          \n          //除去bigArr中的repeatArr中的元素\n          const removeTheRepeatArr = (bigArr,repeatArr)=>{\n              let obj = {};\n              for(let item of repeatArr){\n                  obj[item] = 1;\n              }\n              \n              for(let i=0;i < bigArr.length;i++){\n                  if(obj[bigArr[i]]){\n                      bigArr.splice(i,1);\n                      i--;\n                  }\n              }\n              return bigArr;\n          }\n          \n          \n          // let arr1 = ['id','nv','ut','wa','ca'];\n          // let arr2 = ['id','nv','ut','mt','or','az'];\n          // let result = removeTheRepeatArr(arr2,arr1);\n          // console.log('result ->',result);\n          let result = test();\n          log('result ->',result)\n","slug":"贪婪算法之近似算法（广播集合覆盖问题）","published":1,"_id":"cjq4l55ze0008dchac8vxygl0","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。</p>\n</li>\n<li><p>贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果：</p>\n<ul>\n<li><p>贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。</p>\n</li>\n<li><p>必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。</p>\n</li>\n<li><p>广度优先、狄克斯特拉算法，近似算法,动态规划,只是在其问题策略的选择上，刚好可以得到最优解。</p>\n</li>\n</ul>\n</li>\n<li><p>判断近似算法的优劣标准如下:</p>\n<ul>\n<li>速度有多快</li>\n<li>得到的近似解与最优解的接近程度</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"案例-广播集合覆盖问题\"><a href=\"#案例-广播集合覆盖问题\" class=\"headerlink\" title=\"案例:广播集合覆盖问题\"></a>案例:广播集合覆盖问题</h4><pre><code>const log = console.log.bind(this);\nconst test = ()=&gt;{\n    let states = {};\n    states[&apos;kone&apos;] = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;]\n    states[&apos;ktwo&apos;] = [&apos;wa&apos;,&apos;id&apos;,&apos;mt&apos;]\n    states[&apos;kthree&apos;] = [&apos;or&apos;,&apos;nv&apos;,&apos;ca&apos;]\n    states[&apos;kfour&apos;] = [&apos;nv&apos;,&apos;ut&apos;]\n    states[&apos;kfive&apos;] = [&apos;ca&apos;,&apos;az&apos;]\n\n    let statesNeeded = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;wa&apos;,&apos;ca&apos;,&apos;mt&apos;,&apos;or&apos;,&apos;az&apos;];\n    let bestStation = [];\n    let statesCovered = [];//所有未覆盖的州\n    let couvered = [];//包含当前光比太覆盖一系列未覆盖的州\n    let finalStation = [];//最后的集合\n\n    while(statesNeeded.length){\n          statesCovered = [];\n          bestStation = [];\n          for(let state in states){\n              couvered = getTheRepeatArr(states[state],statesNeeded);\n              log(&apos;couvered -&gt;&apos;,couvered);\n              log(&apos;statesCovered -&gt;&apos;,statesCovered);\n              //判断未覆盖州中取最大的\n              if(couvered.length &gt; statesCovered.length){\n                  bestStation = state;\n                  statesCovered = couvered;\n              }\n          }\n        log(&apos;statesCovered -&gt;&apos;,statesCovered);\n        statesNeeded = removeTheRepeatArr(statesNeeded,statesCovered)\n        log(&apos;statesNeeded -&gt;&apos;,statesNeeded);\n        log(&apos;bestStation -&gt;&apos;,bestStation);\n        log(&apos;--------------&gt;&apos;);\n        finalStation.push(bestStation);\n      }\n    return finalStation;\n}\n\n    //获得重复的数组元素\n    const getTheRepeatArr = (arr1,arr2)=&gt;{\n        let obj = {};\n        let repeatArr = [];\n        for(let item of arr1){\n            obj[item] = 1;\n        }\n        for(let item of arr2){\n            if(obj[item]){\n                obj[item] = 2;\n                repeatArr.push(item);\n            }else{\n                obj[item] = 1;\n            }\n        }\n        return repeatArr;\n    }\n\n    //除去bigArr中的repeatArr中的元素\n    const removeTheRepeatArr = (bigArr,repeatArr)=&gt;{\n        let obj = {};\n        for(let item of repeatArr){\n            obj[item] = 1;\n        }\n\n        for(let i=0;i &lt; bigArr.length;i++){\n            if(obj[bigArr[i]]){\n                bigArr.splice(i,1);\n                i--;\n            }\n        }\n        return bigArr;\n    }\n\n\n    // let arr1 = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;wa&apos;,&apos;ca&apos;];\n    // let arr2 = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;mt&apos;,&apos;or&apos;,&apos;az&apos;];\n    // let result = removeTheRepeatArr(arr2,arr1);\n    // console.log(&apos;result -&gt;&apos;,result);\n    let result = test();\n    log(&apos;result -&gt;&apos;,result)\n</code></pre>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。</p>\n</li>\n<li><p>贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果：</p>\n<ul>\n<li><p>贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。</p>\n</li>\n<li><p>必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。</p>\n</li>\n<li><p>广度优先、狄克斯特拉算法，近似算法,动态规划,只是在其问题策略的选择上，刚好可以得到最优解。</p>\n</li>\n</ul>\n</li>\n<li><p>判断近似算法的优劣标准如下:</p>\n<ul>\n<li>速度有多快</li>\n<li>得到的近似解与最优解的接近程度</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"案例-广播集合覆盖问题\"><a href=\"#案例-广播集合覆盖问题\" class=\"headerlink\" title=\"案例:广播集合覆盖问题\"></a>案例:广播集合覆盖问题</h4><pre><code>const log = console.log.bind(this);\nconst test = ()=&gt;{\n    let states = {};\n    states[&apos;kone&apos;] = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;]\n    states[&apos;ktwo&apos;] = [&apos;wa&apos;,&apos;id&apos;,&apos;mt&apos;]\n    states[&apos;kthree&apos;] = [&apos;or&apos;,&apos;nv&apos;,&apos;ca&apos;]\n    states[&apos;kfour&apos;] = [&apos;nv&apos;,&apos;ut&apos;]\n    states[&apos;kfive&apos;] = [&apos;ca&apos;,&apos;az&apos;]\n\n    let statesNeeded = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;wa&apos;,&apos;ca&apos;,&apos;mt&apos;,&apos;or&apos;,&apos;az&apos;];\n    let bestStation = [];\n    let statesCovered = [];//所有未覆盖的州\n    let couvered = [];//包含当前光比太覆盖一系列未覆盖的州\n    let finalStation = [];//最后的集合\n\n    while(statesNeeded.length){\n          statesCovered = [];\n          bestStation = [];\n          for(let state in states){\n              couvered = getTheRepeatArr(states[state],statesNeeded);\n              log(&apos;couvered -&gt;&apos;,couvered);\n              log(&apos;statesCovered -&gt;&apos;,statesCovered);\n              //判断未覆盖州中取最大的\n              if(couvered.length &gt; statesCovered.length){\n                  bestStation = state;\n                  statesCovered = couvered;\n              }\n          }\n        log(&apos;statesCovered -&gt;&apos;,statesCovered);\n        statesNeeded = removeTheRepeatArr(statesNeeded,statesCovered)\n        log(&apos;statesNeeded -&gt;&apos;,statesNeeded);\n        log(&apos;bestStation -&gt;&apos;,bestStation);\n        log(&apos;--------------&gt;&apos;);\n        finalStation.push(bestStation);\n      }\n    return finalStation;\n}\n\n    //获得重复的数组元素\n    const getTheRepeatArr = (arr1,arr2)=&gt;{\n        let obj = {};\n        let repeatArr = [];\n        for(let item of arr1){\n            obj[item] = 1;\n        }\n        for(let item of arr2){\n            if(obj[item]){\n                obj[item] = 2;\n                repeatArr.push(item);\n            }else{\n                obj[item] = 1;\n            }\n        }\n        return repeatArr;\n    }\n\n    //除去bigArr中的repeatArr中的元素\n    const removeTheRepeatArr = (bigArr,repeatArr)=&gt;{\n        let obj = {};\n        for(let item of repeatArr){\n            obj[item] = 1;\n        }\n\n        for(let i=0;i &lt; bigArr.length;i++){\n            if(obj[bigArr[i]]){\n                bigArr.splice(i,1);\n                i--;\n            }\n        }\n        return bigArr;\n    }\n\n\n    // let arr1 = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;wa&apos;,&apos;ca&apos;];\n    // let arr2 = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;mt&apos;,&apos;or&apos;,&apos;az&apos;];\n    // let result = removeTheRepeatArr(arr2,arr1);\n    // console.log(&apos;result -&gt;&apos;,result);\n    let result = test();\n    log(&apos;result -&gt;&apos;,result)\n</code></pre>"},{"title":"将hexo配置到github上","date":"2017-12-09T17:17:31.000Z","updated":"2018-12-26T02:56:06.400Z","thumbnail":"/images/将hexo配置到github上/bg.png","_content":">  可以参考[这篇文章](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)\n\n## github\n\n1.  在github上面建一个和你的账号一样的项目，比如账号是【caozihao】，项目名为【caozihao.github.io】\n\n2.  配置SSH，获取权限\n    \n        ssh-keygen -t rsa -C \"[email]\"\n\n>   这个邮箱是你在github上注册的邮箱\n\n3.  找到并打开 id_rsa.pub 文件，地址是\n    \n        C:\\Users\\Skull\\.ssh\n\n4.  将内容复制到github上的ssh里的key内容框里，目录为\n    \n        头像/SSH and GPG keys\n\n5.  检测是否成功，控制台输入指令\n    \n        ssh -T git@github.com\n    \n    如果显示\n\n        Hi caozihao! You've successfully authenticated, but GitHub does not provide shell access.\n    \n    说明配置成功\n\n6.  为了方便不要每次push都要输入账号密码，有两种做法，一种是走SSH,配置key,就是上面这种不;另外一种是用https的，配credential helper，指令如下\n    \n        git config --global credential.helper store\n\n##  Hexo项目\n1.  在_config.yml文件中，找到deploy,将 repository 属性配置为 你的那个访问页面项目的地址\n    \n        deploy:\n          type: git\n          repository: https://github.com/caozihao/caozihao.github.io.git\n          branch: master\n\n2.  安装 hexo-deployer-git  自动部署发布工具\n    \n         npm install hexo-deployer-git  --save\n\n3.  部署发布\n    \n        hexo g -d\n    \n    如果最后出现\n\n        INFO Deploy done:git\n        \n    说明部署成功\n    \n4.  访问网站 https://caozihao.github.io/ 看看部署好了没有\n    \n\n##  绑定域名\n\n1.  看[这篇](http://blog.csdn.net/u011976726/article/details/78217467)\n\n2.  注意：添加完CNAME文件后，要重新部署一下\n        \n        hexo g -d\n\n3.  注意：域名解析时要添加两个（ANAME和A）","source":"_posts/将hexo配置到github上.md","raw":"---\ntitle: 将hexo配置到github上\ndate: 2017-12-10 01:17:31\nupdated:\ntags:\n- Hexo\n- 配置\nthumbnail: /images/将hexo配置到github上/bg.png\n---\n>  可以参考[这篇文章](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)\n\n## github\n\n1.  在github上面建一个和你的账号一样的项目，比如账号是【caozihao】，项目名为【caozihao.github.io】\n\n2.  配置SSH，获取权限\n    \n        ssh-keygen -t rsa -C \"[email]\"\n\n>   这个邮箱是你在github上注册的邮箱\n\n3.  找到并打开 id_rsa.pub 文件，地址是\n    \n        C:\\Users\\Skull\\.ssh\n\n4.  将内容复制到github上的ssh里的key内容框里，目录为\n    \n        头像/SSH and GPG keys\n\n5.  检测是否成功，控制台输入指令\n    \n        ssh -T git@github.com\n    \n    如果显示\n\n        Hi caozihao! You've successfully authenticated, but GitHub does not provide shell access.\n    \n    说明配置成功\n\n6.  为了方便不要每次push都要输入账号密码，有两种做法，一种是走SSH,配置key,就是上面这种不;另外一种是用https的，配credential helper，指令如下\n    \n        git config --global credential.helper store\n\n##  Hexo项目\n1.  在_config.yml文件中，找到deploy,将 repository 属性配置为 你的那个访问页面项目的地址\n    \n        deploy:\n          type: git\n          repository: https://github.com/caozihao/caozihao.github.io.git\n          branch: master\n\n2.  安装 hexo-deployer-git  自动部署发布工具\n    \n         npm install hexo-deployer-git  --save\n\n3.  部署发布\n    \n        hexo g -d\n    \n    如果最后出现\n\n        INFO Deploy done:git\n        \n    说明部署成功\n    \n4.  访问网站 https://caozihao.github.io/ 看看部署好了没有\n    \n\n##  绑定域名\n\n1.  看[这篇](http://blog.csdn.net/u011976726/article/details/78217467)\n\n2.  注意：添加完CNAME文件后，要重新部署一下\n        \n        hexo g -d\n\n3.  注意：域名解析时要添加两个（ANAME和A）","slug":"将hexo配置到github上","published":1,"_id":"cjq4l55zl000bdchaankcpt5c","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p> 可以参考<a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n</blockquote>\n<h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h2><ol>\n<li><p>在github上面建一个和你的账号一样的项目，比如账号是【caozihao】，项目名为【caozihao.github.io】</p>\n</li>\n<li><p>配置SSH，获取权限</p>\n<pre><code>ssh-keygen -t rsa -C &quot;[email]&quot;\n</code></pre></li>\n</ol>\n<blockquote>\n<p>  这个邮箱是你在github上注册的邮箱</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>找到并打开 id_rsa.pub 文件，地址是</p>\n<pre><code>C:\\Users\\Skull\\.ssh\n</code></pre></li>\n<li><p>将内容复制到github上的ssh里的key内容框里，目录为</p>\n<pre><code>头像/SSH and GPG keys\n</code></pre></li>\n<li><p>检测是否成功，控制台输入指令</p>\n<pre><code>ssh -T git@github.com\n</code></pre><p>如果显示</p>\n<pre><code>Hi caozihao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>说明配置成功</p>\n</li>\n<li><p>为了方便不要每次push都要输入账号密码，有两种做法，一种是走SSH,配置key,就是上面这种不;另外一种是用https的，配credential helper，指令如下</p>\n<pre><code>git config --global credential.helper store\n</code></pre></li>\n</ol>\n<h2 id=\"Hexo项目\"><a href=\"#Hexo项目\" class=\"headerlink\" title=\"Hexo项目\"></a>Hexo项目</h2><ol>\n<li><p>在_config.yml文件中，找到deploy,将 repository 属性配置为 你的那个访问页面项目的地址</p>\n<pre><code>deploy:\n  type: git\n  repository: https://github.com/caozihao/caozihao.github.io.git\n  branch: master\n</code></pre></li>\n<li><p>安装 hexo-deployer-git  自动部署发布工具</p>\n<pre><code>npm install hexo-deployer-git  --save\n</code></pre></li>\n<li><p>部署发布</p>\n<pre><code>hexo g -d\n</code></pre><p>如果最后出现</p>\n<pre><code>INFO Deploy done:git\n</code></pre><p>说明部署成功</p>\n</li>\n<li><p>访问网站 <a href=\"https://caozihao.github.io/\" target=\"_blank\" rel=\"noopener\">https://caozihao.github.io/</a> 看看部署好了没有</p>\n</li>\n</ol>\n<h2 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h2><ol>\n<li><p>看<a href=\"http://blog.csdn.net/u011976726/article/details/78217467\" target=\"_blank\" rel=\"noopener\">这篇</a></p>\n</li>\n<li><p>注意：添加完CNAME文件后，要重新部署一下</p>\n<pre><code>hexo g -d\n</code></pre></li>\n<li><p>注意：域名解析时要添加两个（ANAME和A）</p>\n</li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p> 可以参考<a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n</blockquote>\n<h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h2><ol>\n<li><p>在github上面建一个和你的账号一样的项目，比如账号是【caozihao】，项目名为【caozihao.github.io】</p>\n</li>\n<li><p>配置SSH，获取权限</p>\n<pre><code>ssh-keygen -t rsa -C &quot;[email]&quot;\n</code></pre></li>\n</ol>\n<blockquote>\n<p>  这个邮箱是你在github上注册的邮箱</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>找到并打开 id_rsa.pub 文件，地址是</p>\n<pre><code>C:\\Users\\Skull\\.ssh\n</code></pre></li>\n<li><p>将内容复制到github上的ssh里的key内容框里，目录为</p>\n<pre><code>头像/SSH and GPG keys\n</code></pre></li>\n<li><p>检测是否成功，控制台输入指令</p>\n<pre><code>ssh -T git@github.com\n</code></pre><p>如果显示</p>\n<pre><code>Hi caozihao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>说明配置成功</p>\n</li>\n<li><p>为了方便不要每次push都要输入账号密码，有两种做法，一种是走SSH,配置key,就是上面这种不;另外一种是用https的，配credential helper，指令如下</p>\n<pre><code>git config --global credential.helper store\n</code></pre></li>\n</ol>\n<h2 id=\"Hexo项目\"><a href=\"#Hexo项目\" class=\"headerlink\" title=\"Hexo项目\"></a>Hexo项目</h2><ol>\n<li><p>在_config.yml文件中，找到deploy,将 repository 属性配置为 你的那个访问页面项目的地址</p>\n<pre><code>deploy:\n  type: git\n  repository: https://github.com/caozihao/caozihao.github.io.git\n  branch: master\n</code></pre></li>\n<li><p>安装 hexo-deployer-git  自动部署发布工具</p>\n<pre><code>npm install hexo-deployer-git  --save\n</code></pre></li>\n<li><p>部署发布</p>\n<pre><code>hexo g -d\n</code></pre><p>如果最后出现</p>\n<pre><code>INFO Deploy done:git\n</code></pre><p>说明部署成功</p>\n</li>\n<li><p>访问网站 <a href=\"https://caozihao.github.io/\" target=\"_blank\" rel=\"noopener\">https://caozihao.github.io/</a> 看看部署好了没有</p>\n</li>\n</ol>\n<h2 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h2><ol>\n<li><p>看<a href=\"http://blog.csdn.net/u011976726/article/details/78217467\" target=\"_blank\" rel=\"noopener\">这篇</a></p>\n</li>\n<li><p>注意：添加完CNAME文件后，要重新部署一下</p>\n<pre><code>hexo g -d\n</code></pre></li>\n<li><p>注意：域名解析时要添加两个（ANAME和A）</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq4l55z90005dchahsjqno8m","category_id":"cjq4l55ze0007dcha0ed6xlrr","_id":"cjq4l55zo000ddchar8vzoca9"}],"PostTag":[{"post_id":"cjq4l55z00002dcha7cpctvgg","tag_id":"cjq4l55z60004dchamsedn7p7","_id":"cjq4l55zk000adchakvbgjs9k"},{"post_id":"cjq4l55z40003dchaej75zjhg","tag_id":"cjq4l55zj0009dchav482p3r3","_id":"cjq4l55zq000gdcharxb7v22c"},{"post_id":"cjq4l55z40003dchaej75zjhg","tag_id":"cjq4l55zn000cdchawi70rdc6","_id":"cjq4l55zq000hdchavzb5pgz2"},{"post_id":"cjq4l55z40003dchaej75zjhg","tag_id":"cjq4l55zo000edchalkhvxv7l","_id":"cjq4l55zr000jdchaj2hqudry"},{"post_id":"cjq4l55z90005dchahsjqno8m","tag_id":"cjq4l55zp000fdchaft0qc4ug","_id":"cjq4l55zs000ldchao1lnei11"},{"post_id":"cjq4l55z90005dchahsjqno8m","tag_id":"cjq4l55zq000idcha4su4rgtf","_id":"cjq4l55zt000mdchayfqto6qc"},{"post_id":"cjq4l55zb0006dcha3lqcxvys","tag_id":"cjq4l55z60004dchamsedn7p7","_id":"cjq4l55zu000odchacla6sjwv"},{"post_id":"cjq4l55zb0006dcha3lqcxvys","tag_id":"cjq4l55zs000kdcha4c70iako","_id":"cjq4l55zu000pdcha9ojn0kkg"},{"post_id":"cjq4l55zl000bdchaankcpt5c","tag_id":"cjq4l55zp000fdchaft0qc4ug","_id":"cjq4l55zx000tdcha8rolfhnx"},{"post_id":"cjq4l55zl000bdchaankcpt5c","tag_id":"cjq4l55zw000sdchallb5irby","_id":"cjq4l55zx000udchadyb5ipf8"},{"post_id":"cjq4l55ze0008dchac8vxygl0","tag_id":"cjq4l55zt000ndchandd0oxnp","_id":"cjq4lvhqb000048ha2y7o02qf"}],"Tag":[{"name":"算法","_id":"cjq4l55z60004dchamsedn7p7"},{"name":"动态规划","_id":"cjq4l55zj0009dchav482p3r3"},{"name":"最长公共子串","_id":"cjq4l55zn000cdchawi70rdc6"},{"name":"最长公共子序列","_id":"cjq4l55zo000edchalkhvxv7l"},{"name":"Hexo","_id":"cjq4l55zp000fdchaft0qc4ug"},{"name":"介绍","_id":"cjq4l55zq000idcha4su4rgtf"},{"name":"K最近邻算法","_id":"cjq4l55zs000kdcha4c70iako"},{"name":"贪婪算法","_id":"cjq4l55zt000ndchandd0oxnp"},{"name":"配置","_id":"cjq4l55zw000sdchallb5irby"}]}}